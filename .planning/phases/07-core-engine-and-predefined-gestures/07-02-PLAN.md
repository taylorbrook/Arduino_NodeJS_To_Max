---
phase: 07-core-engine-and-predefined-gestures
plan: 02
type: execute
wave: 2
depends_on:
  - 07-01
files_modified:
  - max/gesture-engine.js
autonomous: true
requirements:
  - GEST-01
  - GEST-02
  - GEST-03
  - GEST-04
  - GEST-05
  - GEST-06
  - GEST-07

must_haves:
  truths:
    - "Shaking the device triggers a 'shake' gesture event when acceleration magnitude exceeds threshold for 3+ consecutive frames"
    - "Tapping the device triggers a 'tap' gesture event from a sharp acceleration spike above the running average"
    - "Flipping the device 180 degrees triggers a 'flip' gesture event after Z-axis sign change is sustained for ~10 frames"
    - "Tilting left/right/forward/back past the angle threshold triggers the corresponding tilt event exactly once, with hysteresis re-arm"
    - "Adjusting the sensitivity dial for any gesture changes its detection threshold"
    - "Each gesture respects its own cooldown period independently"
  artifacts:
    - path: "max/gesture-engine.js"
      provides: "7 gesture detector implementations replacing the stubs from Plan 01"
      contains: "detectShake"
  key_links:
    - from: "detectShake"
      to: "fireGesture"
      via: "fireGesture('shake') when consecutive count met"
      pattern: "fireGesture.*shake"
    - from: "detectTap"
      to: "fireGesture"
      via: "fireGesture('tap') when spike exceeds threshold"
      pattern: "fireGesture.*tap"
    - from: "detectFlip"
      to: "fireGesture"
      via: "fireGesture('flip') when Z sign change confirmed"
      pattern: "fireGesture.*flip"
    - from: "detectTilts/checkTilt"
      to: "fireGesture"
      via: "fireGesture(name) on state change from not-tilted to tilted"
      pattern: "fireGesture.*tilt"
---

<objective>
Implement the 7 predefined gesture detectors (shake, tap, flip, tilt-left, tilt-right, tilt-forward, tilt-back) by replacing the stub functions created in Plan 01 with full detection algorithms.

Purpose: Provides the actual gesture recognition that makes imu-gesture.maxpat useful -- detecting physical device motions and converting them to named events.

Output: Updated `max/gesture-engine.js` with working implementations for all 7 gesture types, each with configurable sensitivity and independent cooldown.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-core-engine-and-predefined-gestures/07-CONTEXT.md
@.planning/phases/07-core-engine-and-predefined-gestures/07-RESEARCH.md
@.planning/phases/07-core-engine-and-predefined-gestures/07-01-SUMMARY.md
@max/gesture-engine.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement shake, tap, and flip detectors</name>
  <files>max/gesture-engine.js</files>
  <action>
Replace the stub implementations of detectShake, detectTap, and detectFlip in gesture-engine.js with full detection algorithms. These three gestures all operate on calibrated (pre-smoothing) acceleration data from the circular buffer.

**Shake detector (GEST-01) -- replace detectShake stub:**

Add state variable above the function:
```javascript
var shakeConsecutiveCount = 0;
var SHAKE_MIN_CONSECUTIVE = 3;  // must exceed threshold for 3+ frames (~26ms at 114Hz)
```

Implementation:
- Compute acceleration magnitude: `Math.sqrt(calFrame.ax^2 + calFrame.ay^2 + calFrame.az^2)`
- Map sensitivity (0.0-1.0) to threshold: `threshold = 1.5 + gestureSensitivity.shake * 2.5` (0.0=very sensitive at 1.5g, 0.5=default 2.75g, 1.0=insensitive at 4.0g)
- If magnitude > threshold: increment shakeConsecutiveCount. If count >= SHAKE_MIN_CONSECUTIVE: call fireGesture("shake"), reset count to 0
- If magnitude <= threshold: reset shakeConsecutiveCount to 0
- Check gestureEnabled.shake at top -- return immediately if disabled

**Tap detector (GEST-02) -- replace detectTap stub:**

Add state variables above the function:
```javascript
var TAP_WINDOW = 10;  // frames for running average (~88ms)
```

Implementation:
- Compute current acceleration magnitude
- Compute running average magnitude from the last TAP_WINDOW frames in the circular buffer using getFrame()
- If bufferCount < TAP_WINDOW, use 1.0 (gravity baseline) as average
- Map sensitivity (0.0-1.0) to spike threshold: `spikeThreshold = 1.5 + gestureSensitivity.tap * 3.5` (default 0.5 = 3.25g above average)
- Compute delta = currentMag - avgMag
- If delta > spikeThreshold: call fireGesture("tap")
- Check gestureEnabled.tap at top -- return immediately if disabled

**Flip detector (GEST-03) -- replace detectFlip stub:**

Add state variables above the function:
```javascript
var flipState = "neutral";  // "neutral" or "confirming"
var flipConfirmCount = 0;
var FLIP_CONFIRM_FRAMES = 10;  // ~88ms sustained inverted
var lastZSign = 0;  // 1 = upright, -1 = inverted, 0 = unknown
```

Implementation:
- Determine currentZSign: calFrame.az > 0 ? 1 : -1
- Map sensitivity (0.0-1.0) to Z threshold: `zThreshold = 0.3 + gestureSensitivity.flip * 0.5` (default 0.5 = 0.55g, meaning device must be clearly oriented not sideways)
- If Math.abs(calFrame.az) < zThreshold: in dead zone (sideways), reset flipState to "neutral", reset flipConfirmCount, return
- If lastZSign !== 0 AND currentZSign !== lastZSign: Z-axis sign changed, set flipState="confirming", flipConfirmCount=1, update lastZSign
- Else if flipState === "confirming": increment flipConfirmCount. If >= FLIP_CONFIRM_FRAMES: call fireGesture("flip"), reset to neutral
- Else: update lastZSign = currentZSign
- Check gestureEnabled.flip at top -- return immediately if disabled

Follow the exact algorithm patterns from 07-RESEARCH.md Code Examples section. Use `var` declarations consistent with the existing codebase style.
  </action>
  <verify>
1. `node -c max/gesture-engine.js` passes (no syntax errors)
2. Verify detectShake contains: magnitude computation, threshold from sensitivity, consecutive count logic, fireGesture("shake") call
3. Verify detectTap contains: running average from buffer, spike delta computation, fireGesture("tap") call
4. Verify detectFlip contains: Z-sign tracking, confirm frames counter, fireGesture("flip") call
5. Verify all three functions check gestureEnabled at entry
  </verify>
  <done>
detectShake fires "shake" when acceleration magnitude exceeds sensitivity-scaled threshold for 3+ consecutive frames. detectTap fires "tap" when current magnitude spikes above the running average by the sensitivity-scaled threshold. detectFlip fires "flip" when Z-axis sign change is sustained for 10+ frames. All three respect enable state and cooldown via fireGesture.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 4 tilt detectors with hysteresis</name>
  <files>max/gesture-engine.js</files>
  <action>
Replace the stub implementation of detectTilts in gesture-engine.js with the full 4-direction tilt detection algorithm. Tilt detection uses SMOOTHED orientation data (not calibrated pre-smoothing) because stable angle readings are needed for tilt thresholds.

**Tilt detector (GEST-04 through GEST-07) -- replace detectTilts stub:**

Add state variable above the function:
```javascript
var tiltArmed = {
  "tilt-left": true, "tilt-right": true,
  "tilt-forward": true, "tilt-back": true
};
```

Implement `detectTilts(smoothedOrient)` which receives an object `{pitch, roll, yaw}` of smoothed orientation values:

1. Create helper function `angleThreshold(name)`: maps sensitivity (0.0-1.0) to angle in degrees.
   - Formula: `15 + gestureSensitivity[name] * 45` (0.0=sensitive at 15 degrees, 0.5=default at 37.5 degrees, 1.0=insensitive at 60 degrees)

2. Create helper function `rearmAngle(name)`: hysteresis re-arm threshold.
   - Formula: `angleThreshold(name) * 0.6` (must return past 60% of threshold to re-arm)

3. Create helper function `checkTilt(name, angle, threshold, rearm)`:
   - Check gestureEnabled[name] -- return if disabled
   - If angle > threshold AND tiltArmed[name]: call fireGesture(name), set tiltArmed[name] = false (disarm until return to neutral)
   - Else if angle < rearm: set tiltArmed[name] = true (re-arm when back near neutral)

4. Call checkTilt for all 4 directions:
   - tilt-left: `checkTilt("tilt-left", -smoothedOrient.roll, angleThreshold("tilt-left"), rearmAngle("tilt-left"))`
   - tilt-right: `checkTilt("tilt-right", smoothedOrient.roll, angleThreshold("tilt-right"), rearmAngle("tilt-right"))`
   - tilt-forward: `checkTilt("tilt-forward", -smoothedOrient.pitch, angleThreshold("tilt-forward"), rearmAngle("tilt-forward"))`
   - tilt-back: `checkTilt("tilt-back", smoothedOrient.pitch, angleThreshold("tilt-back"), rearmAngle("tilt-back"))`

**CRITICAL design notes:**
- Tilt fires on STATE CHANGE only (armed -> fired), NOT on every frame while tilted (see Pitfall 3 in research)
- Hysteresis prevents jitter at threshold boundary: trigger at threshold, re-arm at 60% of threshold
- Tilt uses smoothed orientation (stable angles) while shake/tap/flip use calibrated pre-smoothing data (sharp transients) -- this split is handled in processFrame which already passes the correct data to each detector
- Each tilt direction has independent enable, sensitivity, and cooldown via the per-gesture state objects

Follow the exact algorithm pattern from 07-RESEARCH.md "Tilt Detection Algorithm" code example. The checkTilt helper can be defined inside detectTilts or as a sibling function -- either is fine.
  </action>
  <verify>
1. `node -c max/gesture-engine.js` passes (no syntax errors)
2. Verify tiltArmed state object exists with all 4 directions
3. Verify detectTilts contains: angleThreshold helper, rearmAngle helper, checkTilt function
4. Verify checkTilt implements: armed check -> fire + disarm, rearm check -> re-arm
5. Verify all 4 directions mapped correctly: left=-roll, right=+roll, forward=-pitch, back=+pitch
6. Verify no gesture fires continuously while tilted (state-change-only pattern)
  </verify>
  <done>
detectTilts fires tilt-left, tilt-right, tilt-forward, and tilt-back events exactly once when orientation angle crosses the sensitivity-scaled threshold, then disarms until the device returns past the hysteresis re-arm angle. Each direction has independent enable, sensitivity, and cooldown. No continuous firing while tilted.
  </done>
</task>

</tasks>

<verification>
- `node -c max/gesture-engine.js` passes with all detectors implemented
- All 7 gesture types have full implementations (no stubs remain)
- Shake uses consecutive count pattern on acceleration magnitude
- Tap uses spike-above-average pattern with buffer history
- Flip uses Z-sign change with confirmation frames
- All 4 tilts use state-change-only pattern with hysteresis re-arm
- Every detector checks gestureEnabled at entry
- Every detector uses gestureSensitivity to scale its threshold
- All detectors fire via fireGesture() which handles cooldown
</verification>

<success_criteria>
- All 7 predefined gesture detectors are fully implemented with no stub code remaining
- Each gesture type responds to its characteristic physical motion with configurable sensitivity
- Tilt detectors fire exactly once per state change (not continuously)
- Gesture output flows through fireGesture for consistent cooldown enforcement
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-engine-and-predefined-gestures/07-02-SUMMARY.md`
</output>
