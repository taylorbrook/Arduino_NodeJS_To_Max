---
phase: 07-core-engine-and-predefined-gestures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - max/gesture-engine.js
autonomous: true
requirements:
  - CORE-01
  - CORE-02
  - CORE-03
  - CORE-04
  - GEST-08
  - GEST-09

must_haves:
  truths:
    - "gesture-engine.js loads in Node for Max without errors and starts scanning for Arduino"
    - "gesture-engine.js validates CSV, applies calibration, applies smoothing, and outputs tagged sensor data identical to serial-bridge.js"
    - "Activity gate transitions to active on a single frame of significant motion and returns to idle after 500ms of stillness"
    - "Circular buffer stores the most recent ~64 sensor frames for gesture detector consumption"
    - "Per-gesture enable/disable, sensitivity, and cooldown handlers accept messages from MAX and update internal state"
    - "fireGesture function respects per-gesture cooldown and only fires when gesture is enabled"
  artifacts:
    - path: "max/gesture-engine.js"
      provides: "Self-contained gesture engine with serial I/O, calibration, smoothing, activity gate, circular buffer, and gesture handler framework"
      min_lines: 400
  key_links:
    - from: "max/gesture-engine.js"
      to: "serialport"
      via: "require('serialport')"
      pattern: "require.*serialport"
    - from: "max/gesture-engine.js"
      to: "max-api"
      via: "require('max-api')"
      pattern: "require.*max-api"
    - from: "max/gesture-engine.js"
      to: "MAX outlet"
      via: "maxAPI.outlet('gesture', name)"
      pattern: "maxAPI\\.outlet.*gesture"
    - from: "max/gesture-engine.js"
      to: "MAX outlet"
      via: "maxAPI.outlet('engine_status', state)"
      pattern: "maxAPI\\.outlet.*engine_status"
---

<objective>
Create the core gesture-engine.js Node for Max script with embedded serial I/O, calibration, smoothing, energy-based activity gating, circular buffer, and the gesture handler/firing framework. This is the foundation that Plan 02 (gesture detectors) and Plan 03 (MAX patch) build on.

Purpose: Establishes the self-contained gesture engine that owns its own Arduino connection and sensor processing pipeline, independent of serial-bridge.js and imu-sensor.maxpat.

Output: `max/gesture-engine.js` -- a working Node for Max script that connects to Arduino, processes sensor data, gates activity, maintains a sliding window buffer, and exposes handler API for gesture configuration. Gesture detector functions are stubbed (implemented in Plan 02).
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-core-engine-and-predefined-gestures/07-CONTEXT.md
@.planning/phases/07-core-engine-and-predefined-gestures/07-RESEARCH.md
@node/serial-bridge.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gesture-engine.js with serial I/O, calibration, smoothing, and sensor output</name>
  <files>max/gesture-engine.js</files>
  <action>
Create `max/gesture-engine.js` by copying and adapting the serial I/O, CSV validation, calibration, and smoothing code from `node/serial-bridge.js`. This is a copy-and-adapt approach -- do NOT import serial-bridge.js (it auto-starts scanning on require, which would open a competing serial connection).

The script structure should follow this order:

1. **Requires:** `max-api`, `serialport` (SerialPort + ReadlineParser), `dgram`

2. **Configuration constants:** BAUD_RATE=57600, EXPECTED_FIELDS=9, RECONNECT_INTERVAL_MS=2000

3. **Connection state:** port, parser, reconnectTimer, state, transport, udpSocket, udpPort, wifiIP -- same pattern as serial-bridge.js

4. **Calibration state and functions:** Copy directly from serial-bridge.js: isCalibrating, sampleCount, sampleSums, biasOffsets, orientOffset, blendFactor, lastOrientation, lastSampleTime, TARGET_SAMPLES=200, MIN_SAMPLES=50, BLEND_SPEED=10, and all calibration functions (startCalibration, collectSample, stopCalibrationAndApply, applyCal, getTimeDelta, resetOrientation, restoreOrientation, applyOrientReset)

5. **Smoothing state and functions:** Copy from serial-bridge.js but with FIXED moderate defaults instead of configurable dials: smoothFactors with global=0.3, all groups=0, all per-axis=0. Copy computeAlpha and applySmoothing unchanged. No smooth_* handlers needed (no user dials for smoothing in gesture engine -- use sensible defaults per user decision "minimal sensor UI").

6. **Normalization:** Copy normalizeValue function and NORM_RANGES from serial-bridge.js. Include normalizeEnabled flag (default false) and normalize handler.

7. **Activity gate state (CORE-03):**
   - `activityState = "idle"` ("idle" or "active")
   - `idleTimer = null`
   - `IDLE_TIMEOUT_MS = 500`
   - `ACTIVITY_THRESHOLD = 0.15` (g deviation from 1.0g baseline)

8. **Activity gate function `checkActivity(calFrame)` (CORE-03):**
   - Compute magnitude: `Math.sqrt(ax^2 + ay^2 + az^2)`
   - Compute deviation: `Math.abs(magnitude - 1.0)`
   - If deviation > ACTIVITY_THRESHOLD: instant transition to "active", clear any idleTimer, outlet "engine_status active"
   - If already active and deviation <= threshold and no idleTimer running: start setTimeout(500ms) to transition to "idle"
   - On idle timeout: set activityState="idle", outlet "engine_status idle"
   - CRITICAL: Instant wake (single frame) per user decision. The 500ms timeout only applies to return-to-idle.

9. **Circular buffer (CORE-04):**
   - `BUFFER_SIZE = 64` (~0.56s at 114Hz)
   - `sensorBuffer = new Array(BUFFER_SIZE)`
   - `bufferIndex = 0`
   - `bufferCount = 0`
   - `pushFrame(frame)` -- adds frame object {ax,ay,az,gx,gy,gz,pitch,roll,yaw} to circular buffer
   - `getFrame(samplesAgo)` -- retrieves frame from N samples ago (0 = most recent)

10. **Gesture state (GEST-08, GEST-09):**
    - `gestureEnabled` object: all 7 gestures default true (shake, tap, flip, tilt-left, tilt-right, tilt-forward, tilt-back)
    - `gestureSensitivity` object: all default 0.5 (0.0-1.0 range)
    - `gestureCooldown` object: shake=300, tap=200, flip=800, tilts=400 (milliseconds)
    - `lastFireTime` object: per-gesture last fire timestamp

11. **fireGesture(name) function (GEST-09):**
    - Check gestureEnabled[name] -- return if disabled
    - Check cooldown: if Date.now() - lastFireTime[name] < gestureCooldown[name], return
    - Set lastFireTime[name] = Date.now()
    - `maxAPI.outlet("gesture", name)` -- named gesture event
    - `maxAPI.outlet("gesture_led", name, 1)` -- LED on
    - setTimeout 100ms: `maxAPI.outlet("gesture_led", name, 0)` -- LED off

12. **Gesture detector stubs:** Create empty functions that will be implemented in Plan 02:
    - `detectShake(calFrame)` -- stub, no-op
    - `detectTap(calFrame)` -- stub, no-op
    - `detectFlip(calFrame)` -- stub, no-op
    - `detectTilts(smoothedOrient)` -- stub, no-op

13. **Data processing pipeline `processFrame(values)`:** Adapted from serial-bridge.js `outputData(values)` but adds gesture detection steps:
    - Parse 9 values into ax,ay,az,gx,gy,gz,pitch,roll,yaw
    - Store lastOrientation
    - Output raw: accel, gyro, orientation (same tags as serial-bridge.js)
    - Collect calibration sample if calibrating
    - If biasOffsets exist: apply calibration, output cal_accel/cal_gyro/cal_orientation
    - Apply smoothing to calibrated data, output smooth_accel/smooth_gyro/smooth_orientation
    - If normalizeEnabled: output norm_accel/norm_gyro/norm_orientation
    - **NEW for gesture engine:** Push calibrated (pre-smoothing) frame to circular buffer via pushFrame()
    - **NEW for gesture engine:** Call checkActivity(calFrame)
    - **NEW for gesture engine:** If activityState === "active", call all gesture detector stubs:
      - detectShake(calFrame)
      - detectTap(calFrame)
      - detectFlip(calFrame)
      - detectTilts({pitch: smoothedPitch, roll: smoothedRoll, yaw: smoothedYaw}) -- tilts use smoothed orientation for stability (per research)
    - Handle orientOffset-only case (same as serial-bridge.js)

14. **Connection functions:** Copy from serial-bridge.js: findArduinoPort, connectToPort, cleanup, startUDP, stopUDP, startScanning, validateLine. In connectToPort, the parser.on("data") callback should call `processFrame(values)` instead of `outputData(values)`.

15. **MAX message handlers (GEST-08):**
    - Copy from serial-bridge.js: connect, disconnect, listports, reset, calibrate_start, calibrate_stop, calibrate_reset, orient_reset, orient_restore, transport, udpport, ip, normalize
    - **NEW gesture handlers:**
      - `gesture_enable(name, val)` -- sets gestureEnabled[name] = (val === 1)
      - `gesture_sensitivity(name, val)` -- sets gestureSensitivity[name] = val (0.0-1.0)
      - `gesture_cooldown(name, val)` -- sets gestureCooldown[name] = val (milliseconds)

16. **Auto-start:** Call `startScanning()` and `maxAPI.outlet("cal_status", "idle")` at bottom of file (same as serial-bridge.js).

Add a console warning at the top of the auto-start section:
`maxAPI.post("[gesture-engine] WARNING: ensure imu-sensor.maxpat is not also running -- both patches cannot share the same serial port");`

Important notes:
- Do NOT include the 13 smoothing handlers from serial-bridge.js (smooth_global, smooth_accel_group, etc.) -- gesture engine uses fixed smoothing defaults
- DO include the normalize handler (for normalized output toggle)
- All outlet tags must match serial-bridge.js conventions for sensor data so the MAX patch can use the same routing pattern
- Use `var` declarations (not `let`/`const` for mutable state) consistent with serial-bridge.js style
  </action>
  <verify>
1. Run `node -c max/gesture-engine.js` -- should report no syntax errors
2. Verify file contains all required sections by checking for key patterns:
   - `require("max-api")` and `require("serialport")`
   - `checkActivity` function
   - `pushFrame` and `getFrame` functions
   - `fireGesture` function
   - `gesture_enable`, `gesture_sensitivity`, `gesture_cooldown` handlers
   - `detectShake`, `detectTap`, `detectFlip`, `detectTilts` stub functions
   - `processFrame` function calling gesture detectors when active
3. Verify file is 400+ lines (substantial script with all infrastructure)
  </verify>
  <done>
gesture-engine.js exists in max/ directory, passes syntax check, contains complete serial I/O pipeline (adapted from serial-bridge.js), activity gate with instant wake and 500ms idle timeout, 64-frame circular buffer, gesture enable/disable/sensitivity/cooldown state and handlers, fireGesture with cooldown debounce, and stub functions for all 7 gesture detectors ready for Plan 02 implementation.
  </done>
</task>

</tasks>

<verification>
- `node -c max/gesture-engine.js` passes (no syntax errors)
- File contains all serial I/O, calibration, smoothing, activity gate, buffer, and handler code
- Gesture detector stubs exist and are called from processFrame when activity state is active
- All 15 MAX handlers present (connection + calibration + gesture config + normalize)
- Outlet tags for sensor data match serial-bridge.js conventions
</verification>

<success_criteria>
- gesture-engine.js is a self-contained Node for Max script that can be loaded by node.script
- Serial connection, calibration, smoothing work identically to serial-bridge.js (copied code)
- Activity gate correctly implements instant wake + delayed idle
- Circular buffer stores 64 frames of calibrated sensor history
- Gesture framework (enable/disable, sensitivity, cooldown, fireGesture) is complete and ready for detectors
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-engine-and-predefined-gestures/07-01-SUMMARY.md`
</output>
