---
phase: 03-calibration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - node/serial-bridge.js
autonomous: true

must_haves:
  truths:
    - "Calibration start/stop/reset handlers respond to MAX messages"
    - "Bias offsets computed from stationary samples correct raw accel and gyro values"
    - "Accelerometer Z-axis bias accounts for 1g gravity (flat reads exactly 1.0g after cal)"
    - "Orientation reset smoothly transitions all three axes toward zero"
    - "Orientation restore smoothly returns to gravity-referenced frame"
    - "Calibration reset also clears orientation offset"
    - "Calibrated outlets only fire when biasOffsets exist (no duplicate IPC when uncalibrated)"
    - "On script startup, cal_status idle is sent to sync MAX UI"
  artifacts:
    - path: "node/serial-bridge.js"
      provides: "Calibration logic, orientation reset, calibrated outlet output"
      contains: "calibrate_start"
  key_links:
    - from: "maxAPI.addHandler(calibrate_start)"
      to: "startCalibration()"
      via: "handler registration"
      pattern: "addHandler.*calibrate_start"
    - from: "maxAPI.addHandler(calibrate_stop)"
      to: "stopCalibrationAndApply()"
      via: "handler registration"
      pattern: "addHandler.*calibrate_stop"
    - from: "outputData()"
      to: "maxAPI.outlet(cal_accel)"
      via: "applyCal() then outlet"
      pattern: "outlet.*cal_accel"
    - from: "outputData()"
      to: "maxAPI.outlet(cal_orientation)"
      via: "applyOrientReset() then outlet"
      pattern: "outlet.*cal_orientation"
    - from: "maxAPI.addHandler(calibrate_reset)"
      to: "orientOffset = null"
      via: "reset clears both bias and orient"
      pattern: "calibrate_reset.*orientOffset.*null"
---

<objective>
Add calibration logic to the Node for Max serial bridge -- bias offset calibration for gyro and accelerometer via stationary sample averaging, full orientation reset with smooth exponential decay transition, and calibrated data outlets.

Purpose: This is the computational core of Phase 3. All calibration math, state management, control handlers, and calibrated data output live in serial-bridge.js. The MAX patch UI (Plan 02) will wire controls to these handlers and display the calibrated output.

Output: Extended serial-bridge.js with 5 new maxAPI handlers (calibrate_start, calibrate_stop, calibrate_reset, orient_reset, orient_restore) and 6 new outlet tags (cal_accel, cal_gyro, cal_orientation, cal_status, cal_progress, cal_bias).
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calibration/03-CONTEXT.md
@.planning/phases/03-calibration/03-RESEARCH.md
@node/serial-bridge.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add calibration state, sample collection, and bias computation</name>
  <files>node/serial-bridge.js</files>
  <action>
Add calibration state variables and functions to serial-bridge.js. Insert a new section after the existing "---- State ----" block.

**Calibration state variables (all session-only, no persistence):**
- `isCalibrating` (boolean, false) -- whether currently collecting samples
- `sampleCount` (number, 0) -- samples collected so far
- `sampleSums` (object {ax,ay,az,gx,gy,gz}, all 0) -- running sums
- `biasOffsets` (object or null) -- computed bias offsets, null = uncalibrated
- `orientOffset` (object {pitch,roll,yaw} or null) -- orientation zero offset, null = no reset
- `blendFactor` (number, 1.0) -- 0.0 to 1.0 for smooth orient transitions
- `lastOrientation` (object {pitch,roll,yaw} or null) -- most recent orientation for orient_reset capture
- `lastSampleTime` (number or null) -- for dt calculation in exponential decay

**Constants:**
- `TARGET_SAMPLES = 200` (~1.75s at 114 Hz)
- `MIN_SAMPLES = 50` (minimum before apply is allowed)
- `BLEND_SPEED = 10` (converges ~99% in 500ms)

**Functions to add:**

1. `startCalibration()` -- sets isCalibrating=true, resets sampleCount to 0, resets sampleSums to all zeros, outlets cal_status "collecting"

2. `collectSample(ax, ay, az, gx, gy, gz)` -- if not isCalibrating, return. Add values to sampleSums, increment sampleCount, outlet cal_progress with (sampleCount, TARGET_SAMPLES)

3. `stopCalibrationAndApply()` -- if not isCalibrating, return. Set isCalibrating=false. If sampleCount < MIN_SAMPLES, outlet cal_status "too_few_samples" and return without applying. Otherwise compute biasOffsets by dividing sums by count. CRITICAL: For az (accelerometer Z), bias = (sum/count) - 1.0 to account for gravity. All other axes: bias = sum/count. Outlet cal_status "applied". Outlet cal_bias with all 6 bias values. Log biases via maxAPI.post.

4. `applyCal(ax, ay, az, gx, gy, gz)` -- if biasOffsets is null, return unchanged values. Return object with each value minus its corresponding bias offset.

5. `getTimeDelta()` -- computes dt in seconds from lastSampleTime using Date.now(). On first call (lastSampleTime null), assume 1/114. Store current time.

6. `resetOrientation(pitch, roll, yaw)` -- capture current orientation as orientOffset, set blendFactor to 0.0, outlet cal_status "orient_reset"

7. `restoreOrientation()` -- set orientOffset to null, set blendFactor to 0.0 (smooth transition back), outlet cal_status "orient_restored"

8. `applyOrientReset(pitch, roll, yaw, dt)` -- advance blendFactor toward 1.0 using exponential decay: `blendFactor += (1.0 - blendFactor) * (1.0 - Math.exp(-BLEND_SPEED * dt))`. Snap to 1.0 if > 0.999 (prevents perpetual floating-point noise). If orientOffset is null, return {pitch, roll, yaw} unchanged. Otherwise subtract (orientOffset * blendFactor) from each axis. For yaw, normalize result to 0-360: `((yaw - offsetYaw) % 360 + 360) % 360`.

**Modify existing `outputData(values)` function:**
- After extracting pitch/roll/yaw, store as lastOrientation = {pitch, roll, yaw}
- Keep existing 3 raw outlet calls (accel, gyro, orientation) -- DO NOT change them
- If isCalibrating, call collectSample(ax, ay, az, gx, gy, gz)
- If biasOffsets is not null: call applyCal to get corrected values, outlet cal_accel with corrected accel, outlet cal_gyro with corrected gyro. Call getTimeDelta(), then applyOrientReset(pitch, roll, yaw, dt) and outlet cal_orientation with the result.
- If biasOffsets is null AND orientOffset is not null: still apply orientation reset to orientation values and outlet cal_orientation (orientation reset is independent of bias calibration)

**Register 5 new maxAPI handlers (add after existing handlers):**
- "calibrate_start" -> calls startCalibration()
- "calibrate_stop" -> calls stopCalibrationAndApply()
- "calibrate_reset" -> sets biasOffsets=null, orientOffset=null, blendFactor=1.0, outlets cal_status "idle", logs reset via maxAPI.post
- "orient_reset" -> if lastOrientation exists, calls resetOrientation with lastOrientation values
- "orient_restore" -> calls restoreOrientation()

**At script startup (after existing `startScanning()` call):**
- Add `maxAPI.outlet("cal_status", "idle")` to sync MAX UI on load

Use `var` for variable declarations in function bodies (consistent with existing code style which uses `var` throughout).
  </action>
  <verify>
Read the modified serial-bridge.js and verify:
1. All 5 handlers registered (calibrate_start, calibrate_stop, calibrate_reset, orient_reset, orient_restore)
2. outputData() still calls the 3 original raw outlets unchanged
3. biasOffsets.az computation uses (mean - 1.0) for gravity correction
4. calibrate_reset handler clears BOTH biasOffsets AND orientOffset
5. Yaw normalization uses ((yaw - offset) % 360 + 360) % 360
6. blendFactor snaps to 1.0 when > 0.999
7. cal_status "idle" is sent at startup
8. No new npm dependencies added
  </verify>
  <done>serial-bridge.js contains complete calibration logic: sample collection, bias computation with gravity correction, orientation reset with smooth transition, 5 message handlers, 6 new outlet tags, startup status sync. All existing Phase 2 functionality (raw outlets, reconnection, validation) remains unchanged.</done>
</task>

</tasks>

<verification>
- Read serial-bridge.js to confirm all calibration functions exist
- Verify the 5 addHandler calls are present
- Verify cal_status "idle" is sent at startup
- Verify outputData still sends accel, gyro, orientation raw outlets
- Verify biasOffsets.az uses (mean - 1.0) gravity correction
- Verify yaw wrapping normalization in applyOrientReset
- Verify calibrate_reset clears both biasOffsets and orientOffset
</verification>

<success_criteria>
- serial-bridge.js extended with calibration logic (~100-150 additional lines)
- 5 new maxAPI.addHandler() registrations
- 6 new outlet tags used (cal_accel, cal_gyro, cal_orientation, cal_status, cal_progress, cal_bias)
- All existing Phase 2 raw outlet behavior preserved
- No new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-calibration/03-01-SUMMARY.md`
</output>
