---
phase: 01-arduino-firmware
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - firmware/imu_firmware/imu_firmware.ino
autonomous: true

must_haves:
  truths:
    - "Firmware compiles without errors for Arduino Uno WiFi Rev2 board"
    - "SparkFun LSM6DS3 library is installed with MSB_FIRST bug fixed"
    - "MadgwickAHRS library is installed"
    - "Sketch contains IMU init, Madgwick warmup, EMA smoothing, CSV output, and reset command"
  artifacts:
    - path: "firmware/imu_firmware/imu_firmware.ino"
      provides: "Complete Arduino firmware for IMU reading, fusion, smoothing, and serial output"
      min_lines: 120
      contains: "LSM6DS3"
  key_links:
    - from: "firmware/imu_firmware/imu_firmware.ino"
      to: "SparkFunLSM6DS3.h"
      via: "include directive"
      pattern: "#include.*SparkFunLSM6DS3"
    - from: "firmware/imu_firmware/imu_firmware.ino"
      to: "MadgwickAHRS.h"
      via: "include directive"
      pattern: "#include.*MadgwickAHRS"
    - from: "firmware/imu_firmware/imu_firmware.ino"
      to: "SPI IMU constructor"
      via: "LSM6DS3(SPI_MODE, SPIIMU_SS)"
      pattern: "LSM6DS3.*SPI_MODE.*SPIIMU_SS"
    - from: "firmware/imu_firmware/imu_firmware.ino"
      to: "Madgwick filter sample rate"
      via: "filter.begin(measuredRate)"
      pattern: "filter\\.begin\\(measured"
---

<objective>
Install required Arduino libraries, fix the known SparkFun compilation bug, and write the complete IMU firmware sketch that reads the LSM6DS3 via SPI, runs Madgwick sensor fusion, applies EMA smoothing to orientation, and outputs 9-value CSV lines over USB serial at 57600 baud.

Purpose: Produce a compilable, upload-ready firmware that satisfies all ARDU-01 through ARDU-06 requirements. This is the foundation of the entire sensor pipeline.
Output: A complete imu_firmware.ino sketch and properly installed/patched libraries.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-arduino-firmware/01-CONTEXT.md
@.planning/phases/01-arduino-firmware/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Arduino libraries and fix SparkFun compilation bug</name>
  <files>
    (Library files managed by arduino-cli, not project source)
  </files>
  <action>
    1. Install arduino-cli if not already available (brew install arduino-cli).
    2. Install the Arduino megaAVR board core if not present: `arduino-cli core install arduino:megaavr`
    3. Install SparkFun LSM6DS3 library: `arduino-cli lib install "SparkFun LSM6DS3 Breakout"` (version 1.0.3)
    4. Install MadgwickAHRS library: `arduino-cli lib install "Madgwick"` (version 1.2.0)
    5. Fix the known SparkFun compilation bug: In the installed library file SparkFunLSM6DS3.cpp, find the line containing `MSB_FIRST` and change it to `MSBFIRST` (remove the underscore). The file is located at ~/Arduino/libraries/SparkFun_LSM6DS3_Breakout/src/SparkFunLSM6DS3.cpp (or equivalent path from `arduino-cli config dump`).
    6. Verify the fix by checking the file contains `MSBFIRST` and not `MSB_FIRST`.
  </action>
  <verify>
    Run: `arduino-cli lib list | grep -E "SparkFun|Madgwick"` -- both libraries should appear.
    Run: `grep -c "MSB_FIRST" ~/Arduino/libraries/SparkFun_LSM6DS3_Breakout/src/SparkFunLSM6DS3.cpp` -- should return 0 (no remaining MSB_FIRST with underscore).
    Run: `grep -c "MSBFIRST" ~/Arduino/libraries/SparkFun_LSM6DS3_Breakout/src/SparkFunLSM6DS3.cpp` -- should return a positive number.
  </verify>
  <done>SparkFun LSM6DS3 and MadgwickAHRS libraries installed. MSB_FIRST bug patched to MSBFIRST. Libraries appear in arduino-cli lib list.</done>
</task>

<task type="auto">
  <name>Task 2: Write complete IMU firmware sketch</name>
  <files>firmware/imu_firmware/imu_firmware.ino</files>
  <action>
    Create the directory structure `firmware/imu_firmware/` and write `imu_firmware.ino` with the following sections:

    **Includes and Configuration Constants (top of file):**
    - `#include "SparkFunLSM6DS3.h"`, `#include "SPI.h"`, `#include <MadgwickAHRS.h>`
    - `const long BAUD_RATE = 57600;`
    - `const int WARMUP_ITERATIONS = 200;` (approx 2 seconds at ~100 Hz computation rate)
    - `const float SMOOTH_ALPHA = 0.15;` (EMA smoothing coefficient -- light smoothing, easy to tune)
    - `const char FIRMWARE_VERSION[] = "1.0";`

    **Global Objects:**
    - `LSM6DS3 myIMU(SPI_MODE, SPIIMU_SS);` -- MUST use SPI mode with board's chip select constant (per research pitfall 5)
    - `Madgwick filter;`
    - Smoothing state: `float smoothPitch = 0, smoothRoll = 0, smoothYaw = 0;`
    - Timing state: `unsigned long lastMicros = 0;` and `float measuredRate = 80.0;` (initial estimate)

    **setup() function:**
    1. `Serial.begin(57600);` then `while (!Serial);` to wait for USB serial connection
    2. `pinMode(LED_BUILTIN, OUTPUT);`
    3. Configure IMU settings BEFORE calling begin():
       - `myIMU.settings.gyroEnabled = 1;`
       - `myIMU.settings.gyroRange = 2000;` (max dps, avoid clipping per user decision)
       - `myIMU.settings.gyroSampleRate = 416;` (Hz, faster than loop so always fresh data)
       - `myIMU.settings.gyroBandWidth = 100;` (Hz anti-alias)
       - `myIMU.settings.accelEnabled = 1;`
       - `myIMU.settings.accelRange = 16;` (max g, avoid clipping per user decision)
       - `myIMU.settings.accelSampleRate = 416;` (Hz, match gyro)
       - `myIMU.settings.accelBandWidth = 100;` (Hz anti-alias)
    4. Call `myIMU.begin()` -- if it returns non-zero, print `ERROR:IMU_INIT_FAILED` and enter infinite LED blink loop (halt)
    5. Call `performWarmup()` (see helper function below)
    6. Print startup line: `STARTUP,device=ARUIDO_IMU,version=1.0,rate_hz=XX.X,format=ax,ay,az,gx,gy,gz,pitch,roll,yaw`
       where XX.X is the measuredRate from warmup
    7. Initialize `lastMicros = micros();`

    **performWarmup() helper function:**
    1. First pass (WARMUP_ITERATIONS): read all 6 sensor values, call `filter.updateIMU()` in a tight loop (no serial output, no delay). Time this pass with micros().
    2. Calculate `measuredRate = WARMUP_ITERATIONS / (elapsed / 1000000.0f)`
    3. Reinitialize filter with measured rate: `filter.begin(measuredRate);`
    4. Second pass (WARMUP_ITERATIONS): re-run the same sensor-read + filter-update loop at the correct rate, so the quaternion converges properly.
    5. Initialize smoothing state from final filter values: `smoothPitch = filter.getPitch(); smoothRoll = filter.getRoll(); smoothYaw = filter.getYaw();`

    **loop() function:**
    1. Read 6 raw values: `myIMU.readFloatAccelX/Y/Z()` (returns g), `myIMU.readFloatGyroX/Y/Z()` (returns dps)
    2. Update Madgwick: `filter.updateIMU(gx, gy, gz, ax, ay, az);` -- library converts dps to rad/s internally
    3. Get orientation: `filter.getPitch()`, `filter.getRoll()`, `filter.getYaw()`
    4. Apply EMA smoothing to orientation values ONLY (not raw accel/gyro):
       - For pitch and roll: standard EMA `smoothed = alpha * new + (1 - alpha) * smoothed`
       - For yaw: angle-aware EMA to handle 360/0 boundary wrapping. Calculate the shortest angular difference, apply that difference scaled by alpha. Implementation:
         ```
         float yawDiff = yaw - smoothYaw;
         if (yawDiff > 180.0) yawDiff -= 360.0;
         if (yawDiff < -180.0) yawDiff += 360.0;
         smoothYaw += SMOOTH_ALPHA * yawDiff;
         if (smoothYaw < 0) smoothYaw += 360.0;
         if (smoothYaw >= 360.0) smoothYaw -= 360.0;
         ```
    5. Output CSV line using `Serial.print(value, 2)` for all 9 values, comma-separated, terminated with `Serial.println()`:
       `ax,ay,az,gx,gy,gz,smoothPitch,smoothRoll,smoothYaw`
       Do NOT use String class. Do NOT add labels. Use Serial.print(',') between values.
    6. Check for incoming reset command: `if (Serial.available() && Serial.read() == 'R') { performWarmup(); }` -- this allows Phase 3 to trigger a yaw reset and filter re-convergence.

    **Important implementation notes:**
    - Do NOT use delay() anywhere in loop(). The loop runs free, paced naturally by SPI reads + Madgwick computation + Serial.print blocking time.
    - Do NOT use the String class anywhere. All serial output via Serial.print/println with numeric types.
    - Total line length at 2 decimal places should be ~63 bytes or less to stay within bandwidth budget.
    - The loop does NOT need explicit timing control -- serial blocking at 57600 baud naturally paces the loop to ~80-85 Hz.

    Compile-check the sketch after writing: `arduino-cli compile --fqbn arduino:megaavr:uno2018 firmware/imu_firmware/`
  </action>
  <verify>
    Run: `arduino-cli compile --fqbn arduino:megaavr:uno2018 firmware/imu_firmware/`
    The sketch must compile with zero errors. Warnings are acceptable (common with Arduino libraries).
    Run: `wc -l firmware/imu_firmware/imu_firmware.ino` -- should be 120+ lines.
    Visually confirm the .ino file contains: LSM6DS3 SPI constructor, Madgwick filter, performWarmup function, EMA smoothing with angle-aware yaw, CSV output with 9 values, Serial 'R' command check, STARTUP header line.
  </verify>
  <done>
    imu_firmware.ino exists at firmware/imu_firmware/imu_firmware.ino.
    Sketch compiles cleanly for arduino:megaavr:uno2018.
    Contains all required components: SPI IMU init with max ranges (16g/2000dps), Madgwick fusion with measured sample rate, EMA smoothing (alpha 0.15) with angle-aware yaw, 9-value CSV output at 57600 baud, warmup phase, startup header, reset command, and IMU failure handling.
  </done>
</task>

</tasks>

<verification>
1. `arduino-cli compile --fqbn arduino:megaavr:uno2018 firmware/imu_firmware/` exits with code 0
2. `firmware/imu_firmware/imu_firmware.ino` contains all required sections (IMU init, warmup, loop with Madgwick, EMA smoothing, CSV output, reset command)
3. No use of `delay()` in loop(), no use of `String` class, no use of `MSB_FIRST`
4. Serial output format is CSV with 9 values per line at 2 decimal places
5. IMU constructor uses SPI_MODE and SPIIMU_SS
6. Sensor ranges set to maximum (16g accel, 2000 dps gyro)
</verification>

<success_criteria>
- Sketch compiles without errors for the target board
- All 6 ARDU requirements are addressed in the firmware design
- Libraries installed and MSB_FIRST bug patched
- Firmware is upload-ready (pending hardware in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-arduino-firmware/01-01-SUMMARY.md`
</output>
