---
phase: 04-musical-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - max/sensor-pipeline.maxpat
autonomous: true

must_haves:
  truths:
    - "User can adjust smoothing parameters via rotary dials and see sensor noise visibly reduced in real time"
    - "Smoothing defaults to off (pass-through) -- raw calibrated data flows unmodified until user dials up"
    - "Three-tier hierarchy works: global dial affects all axes, group dials affect accel/gyro/orientation groups, per-axis dials fine-tune individual axes"
    - "Quaternion orientation data is displayed as 4 values and available for downstream use"
  artifacts:
    - path: "max/sensor-pipeline.maxpat"
      provides: "Three-tier smoothing module with 13 dials + quaternion output"
      contains: "slide"
  key_links:
    - from: "cal_orientation route outlet"
      to: "slide objects"
      via: "unpack -> slide $1 per axis"
      pattern: "slide"
    - from: "smoothing dials (global, group, per-axis)"
      to: "slide factor input"
      via: "multiplication chain: global * group * per_axis"
      pattern: "multiply"
    - from: "orientation values"
      to: "quaternion display"
      via: "jit.euler2quat -> unpack f f f f -> flonum"
      pattern: "euler2quat"
---

<objective>
Add three-tier EMA smoothing module and quaternion output to the MAX patch.

Purpose: Smoothing is the foundation for all downstream musical tools (mapping and thresholds consume smoothed data). Quaternion output fulfills MAXI-07 and feeds the 3D visualization in Plan 03. Building these first establishes the data flow chain that Plans 02 and 03 build upon.

Output: sensor-pipeline.maxpat extended with 13 smoothing dials (1 global + 3 group + 9 per-axis), slide objects on all 9 sensor axes, and quaternion output from jit.euler2quat with 4 flonum display values.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-musical-tools/04-RESEARCH.md
@.planning/phases/04-musical-tools/04-CONTEXT.md
@.planning/phases/03-calibration/03-02-SUMMARY.md
@max/sensor-pipeline.maxpat
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add three-tier smoothing module with 13 dials and slide objects</name>
  <files>max/sensor-pipeline.maxpat</files>
  <action>
Read the existing sensor-pipeline.maxpat JSON. Add a smoothing module section below the calibrated data display area. The module processes all 9 axes from 3 sources: cal_accel (3 axes), cal_gyro (3 axes), and cal_orientation (3 axes).

SMOOTHING HIERARCHY (per user's locked decision):
- 1 global dial: affects ALL axes. Multiplied with every group+per-axis factor.
- 3 group dials: one each for accel, gyro, orientation. Multiplied with global and per-axis.
- 9 per-axis dials: one per sensor axis (aX, aY, aZ, gX, gY, gZ, pitch, roll, yaw).
- Effective slide factor = max(1, global * group * per_axis). The max(1, ...) ensures minimum factor of 1.
- All 13 dials default to 1 (no smoothing = pass-through per user decision).

DIAL CONFIGURATION (all 13 dials):
- Use MAX `dial` object with attributes: @setminmax 1. 50., @floatoutput 1, @size 40 40
- Initialize each dial to 1 via loadbang -> int 1 -> dial
- Label each dial with a comment: "Global", "Accel Group", "Gyro Group", "Orient Group", "aX", "aY", "aZ", "gX", "gY", "gZ", "Pitch", "Roll", "Yaw"

FACTOR COMPUTATION (for each axis):
- global_factor (from global dial) feeds into 3 multiply objects (one per group)
- Each group multiply: global_factor * group_factor -> feeds into 3 per-axis multiplies
- Each per-axis multiply: (global * group) * per_axis_factor -> feeds into the slide object's right inlet (sets slide factor)
- Use MAX `*` (multiply) objects for the multiplication chain

SLIDE OBJECTS (9 total, one per axis):
- Each axis gets a `slide` object. Sensor value enters left inlet, computed factor enters right inlet.
- slide factor = 1 means output = input (no smoothing). Higher values = more smoothing.
- Wire each calibrated data axis through its slide object.

DATA FLOW:
- [route cal_accel] -> [unpack f f f] -> each axis -> [slide] -> smoothed output
- [route cal_gyro] -> [unpack f f f] -> each axis -> [slide] -> smoothed output
- [route cal_orientation] -> [unpack f f f] -> each axis -> [slide] -> smoothed output
- Display smoothed values in flonum objects (9 new flonums for smoothed data)
- Use [send] objects to broadcast smoothed orientation values for downstream use: [s smooth_pitch], [s smooth_roll], [s smooth_yaw] -- these will be consumed by the 3D viz subpatcher in Plan 03

LAYOUT:
- Place smoothing section below the existing calibrated data display
- Horizontal grouping: Global dial on the left, then Accel group (with 3 per-axis below), Gyro group (with 3 per-axis below), Orient group (with 3 per-axis below)
- Add a comment banner "=== SMOOTHING ===" above the section
- Add 9 flonum objects showing smoothed output values, labeled with comments

IMPORTANT: When no calibration is active, cal_accel/cal_gyro/cal_orientation do not fire (per Phase 3 design). The smoothing module only processes calibrated data. Raw data display remains unchanged above. This is correct behavior -- smoothing operates on calibrated data only.

Also use [send] objects to broadcast smoothed accel and gyro for downstream mapping/thresholds: [s smooth_ax], [s smooth_ay], [s smooth_az], [s smooth_gx], [s smooth_gy], [s smooth_gz].
  </action>
  <verify>
Open sensor-pipeline.maxpat in MAX. Verify:
1. All 13 dials appear with correct labels and default to 1
2. When calibrated data flows (calibrate first), smoothed output matches calibrated output (all dials at 1 = pass-through)
3. Turning the global dial up to ~20 visibly smooths all 9 axes
4. Turning a single per-axis dial smooths only that axis
5. Group dials affect only their 3 axes
6. No smoothing artifacts (frozen output, NaN) at any dial position
  </verify>
  <done>13 smoothing dials control a three-tier EMA hierarchy across all 9 sensor axes via slide objects, defaulting to pass-through (factor=1), with smoothed output displayed in 9 flonums and broadcast via send objects</done>
</task>

<task type="auto">
  <name>Task 2: Add quaternion output via jit.euler2quat</name>
  <files>max/sensor-pipeline.maxpat</files>
  <action>
Add quaternion computation and display to the MAX patch. Quaternion is computed from the orientation values (pitch, roll, yaw) using the Jitter `jit.euler2quat` object. No firmware or Node bridge changes needed (per research finding: 57600 baud cannot carry additional CSV fields).

QUATERNION COMPUTATION:
- Take the orientation values from the existing [route orientation] output (raw orientation, not smoothed -- quaternion should reflect actual orientation)
- [unpack f f f] -> [pack f f f] -> [jit.euler2quat] -> [unpack f f f f] (outputs x, y, z, w in Jitter XYZW order)
- Display in 4 flonum objects labeled qX, qY, qZ, qW

ALSO compute smoothed quaternion for 3D viz (Plan 03 will consume this):
- [r smooth_pitch] [r smooth_roll] [r smooth_yaw] -> [pack f f f] -> [jit.euler2quat] -> [s quat_smooth] (as a list of 4 floats for the 3D viz to receive)
- The smoothed quaternion provides a smooth 3D visualization experience

LAYOUT:
- Place quaternion display near the orientation section (either beside or below it)
- Add a comment "=== QUATERNION ==="
- 4 flonum objects in a row: qX, qY, qZ, qW

NOTE: jit.euler2quat expects input as a list of 3 floats (pitch, roll, yaw) and outputs a list of 4 floats (x, y, z, w). Verify the input/output format matches -- if the object outputs a Jitter matrix rather than a list, use appropriate conversion.

IMPORTANT: The quaternion output uses raw orientation (not smoothed) for accuracy. The smoothed quaternion is a separate path for the 3D visualization only.
  </action>
  <verify>
Open sensor-pipeline.maxpat in MAX. Verify:
1. 4 quaternion flonum values update in real time when Arduino is connected
2. Quaternion values are normalized (magnitude ~1.0: sqrt(qX^2 + qY^2 + qZ^2 + qW^2) approximately 1.0)
3. Tilting the board changes quaternion values smoothly
4. Board at rest shows stable quaternion values (qW near 1.0, others near 0.0 when flat)
  </verify>
  <done>Quaternion orientation output computed from Euler angles via jit.euler2quat, displayed as 4 flonum values, with smoothed quaternion broadcast via send for 3D viz consumption</done>
</task>

</tasks>

<verification>
- All 13 smoothing dials visible with labels and defaulting to 1
- Smoothed output matches calibrated output at default settings (pass-through)
- Increasing any dial visibly reduces noise on corresponding axis/axes
- Three-tier multiplication works correctly: global affects all, group affects 3, per-axis affects 1
- 4 quaternion values displayed and updating in real time
- No additional outlet calls from Node (zero Node bridge changes)
- Patch loads without errors
</verification>

<success_criteria>
- MAXI-01 (smoothing): Three-tier EMA hierarchy operational with 13 dials, defaulting to pass-through
- MAXI-07 (quaternion): 4 quaternion flonum values displayed alongside existing Euler angles
- Data flow established: calibrated -> smoothed -> broadcast via send objects for Plans 02/03
</success_criteria>

<output>
After completion, create `.planning/phases/04-musical-tools/04-01-SUMMARY.md`
</output>
