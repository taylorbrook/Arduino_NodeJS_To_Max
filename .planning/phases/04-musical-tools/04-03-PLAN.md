---
phase: 04-musical-tools
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - max/sensor-pipeline.maxpat
autonomous: false

must_haves:
  truths:
    - "User can define thresholds that fire bang + direction (up/down) when orientation or accel crosses a boundary"
    - "Multiple thresholds per axis work independently (e.g., 30, 45, 60 degrees on pitch)"
    - "Hysteresis prevents threshold oscillation when sensor value hovers near boundary"
    - "3D visualization shows an arrow shape tracking the board's orientation in real time"
    - "3D view is hidden by default and opens/closes on demand without wasting CPU when closed"
  artifacts:
    - path: "max/sensor-pipeline.maxpat"
      provides: "Threshold triggers on 6 axes + 3D viz subpatcher + complete musical tools"
      contains: "jit.world"
  key_links:
    - from: "smoothed sensor value"
      to: "threshold comparators"
      via: "> (threshold + hyst/2) and < (threshold - hyst/2) with change + select"
      pattern: "change"
    - from: "threshold crossing detection"
      to: "bang + direction output"
      via: "select 1 -> bang, message up/down"
      pattern: "select 1"
    - from: "smooth orientation (via receive)"
      to: "jit.gl.gridshape rotatexyz"
      via: "pack f f f -> rotatexyz attribute"
      pattern: "rotatexyz"
    - from: "pcontrol open/close"
      to: "jit.world enable"
      via: "loadbang -> enable 1, closebang -> enable 0"
      pattern: "pcontrol"
---

<objective>
Add threshold triggers with hysteresis on 6 axes and a hideable Jitter 3D orientation visualization to complete all Phase 4 musical tools.

Purpose: Thresholds (MAXI-03) convert continuous sensor data into discrete events for triggering musical actions (notes, effects, scene changes). The 3D visualization (MAXI-06) gives the user visual feedback of board orientation. Together with smoothing (Plan 01) and mapping (Plan 02), these complete the full musical tools phase.

Output: sensor-pipeline.maxpat with threshold trigger modules on 6 axes (3 orientation + 3 accelerometer), a hideable Jitter subpatcher with arrow shape/ground grid/axis lines, and end-to-end hardware verification.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-musical-tools/04-RESEARCH.md
@.planning/phases/04-musical-tools/04-CONTEXT.md
@.planning/phases/04-musical-tools/04-01-SUMMARY.md
@.planning/phases/04-musical-tools/04-02-SUMMARY.md
@max/sensor-pipeline.maxpat
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add threshold trigger modules with hysteresis on 6 axes</name>
  <files>max/sensor-pipeline.maxpat</files>
  <action>
Add threshold trigger modules below the range mapping section. Thresholds are available on orientation axes (pitch, roll, yaw) and accelerometer axes (aX, aY, aZ) per user's locked decision -- NOT on raw gyro.

PER-AXIS THRESHOLD MODULE (6 axes total):

Each axis gets a threshold module supporting MULTIPLE thresholds. Implement 2 thresholds per axis as a starting point (user can add more by duplicating the pattern). Each threshold instance has:

THRESHOLD CONTROLS:
- 1 flonum: threshold value (e.g., 45.0 for 45 degrees)
- 1 dial or flonum: hysteresis width (e.g., 5.0 means dead zone is +/-2.5 around threshold). Default: 5.0. Range: 0-20.

HYSTERESIS LOGIC (per threshold):
- Compute upper bound: threshold + (hysteresis / 2)
- Compute lower bound: threshold - (hysteresis / 2)
- Use [+] and [-] objects with [/ 2] for the hysteresis half-width
- UPWARD crossing: [> upper_bound] -> [change] -> [select 1] -> fires bang + message "up"
- DOWNWARD crossing: [< lower_bound] -> [change] -> [select 1] -> fires bang + message "down"
- The `change` object filters repeated identical values, and `select 1` fires only on the 0->1 transition (the crossing moment)

OUTPUT per threshold:
- [bang] outlet for the crossing event
- [message] outlet with "up" or "down" symbol indicating crossing direction
- A button (MAX [button] object) that visually flashes when the threshold fires -- gives visual feedback

INPUT DATA:
- Use smoothed values via [receive]: [r smooth_pitch], [r smooth_roll], [r smooth_yaw] for orientation
- [r smooth_ax], [r smooth_ay], [r smooth_az] for accelerometer

DEFAULT THRESHOLD VALUES:
- Orientation axes: Threshold 1 = 30., Threshold 2 = 60. (degrees)
- Accelerometer axes: Threshold 1 = 0.5, Threshold 2 = 1.5 (g)
- All hysteresis defaults: 5.0 (orientation) and 0.2 (accelerometer)

LAYOUT:
- Comment banner "=== THRESHOLDS ==="
- Group by axis: "--- Pitch Thresholds ---", "--- Roll Thresholds ---", etc.
- Each threshold instance in a row: threshold flonum | hysteresis dial | visual button (flashes) | direction output
- 2 threshold instances per axis, stacked vertically within each axis section
- Consider using subpatchers per axis (e.g., [p thresh_pitch]) to manage complexity -- Claude's discretion

NOTE: Thresholds operate on SMOOTHED data (not raw). This is correct because the user's smoothing setting already determines the noise floor. Operating on smoothed data means the smoothing dials directly control threshold stability.
  </action>
  <verify>
Open sensor-pipeline.maxpat in MAX with Arduino connected and calibrated. Verify:
1. Tilting board past 30 degrees on pitch fires threshold 1 with "up" direction
2. Returning below 30 degrees fires with "down" direction
3. Hovering near 30 degrees does NOT cause rapid firing (hysteresis working)
4. Second threshold at 60 degrees fires independently
5. Accelerometer thresholds respond to board acceleration
6. Visual button objects flash on threshold crossings
7. Adjusting hysteresis dial changes the dead zone width
  </verify>
  <done>12 threshold instances (2 per axis x 6 axes) with configurable threshold values, adjustable hysteresis, direction output (up/down), and visual feedback buttons</done>
</task>

<task type="auto">
  <name>Task 2: Add hideable Jitter 3D orientation visualization subpatcher</name>
  <files>max/sensor-pipeline.maxpat</files>
  <action>
Add a 3D visualization subpatcher that shows the board's orientation as an arrow shape, opened/closed via a button in the main patch.

MAIN PATCH CONTROLS:
- textbutton in toggle mode: "Show 3D" / "Hide 3D"
- Wire through [select 1 0] -> [message "open"] / [message "close"] -> [pcontrol]
- [pcontrol] controls the subpatcher [p 3d_viz]
- Place the button near the calibration controls or smoothing section

SUBPATCHER [p 3d_viz] CONTENTS:

Arrow shape (Claude's discretion: arrow = cone tip + cylinder shaft):
- [jit.gl.gridshape myworld @shape cone @lighting_enable 1 @scale 0.3 0.3 0.5 @position 0 0.5 0 @color 1.0 0.3 0.2 1.0]  (red-ish tip)
- [jit.gl.gridshape myworld @shape cylinder @lighting_enable 1 @scale 0.15 0.15 0.7 @position 0 -0.1 0 @color 0.3 0.6 1.0 1.0]  (blue shaft)
- Both shapes need to rotate together. Use [r smooth_pitch] [r smooth_roll] [r smooth_yaw] -> [pack f f f] to build a rotation list, then send as rotatexyz attribute to both shapes. Alternatively, group them under a common transform node if Jitter supports it; otherwise, wire the same rotation to both.

Ground plane grid:
- [jit.gl.gridshape myworld @shape plane @lighting_enable 1 @position 0 -1.2 0 @rotatexyz 90 0 0 @scale 3 3 1 @color 0.3 0.3 0.3 1.0 @poly_mode 1 1 @dim 10 10]
- This creates a wireframe grid at the "floor" level

Colored XYZ axis lines:
- Use [jit.gl.sketch myworld @lighting_enable 0] to draw colored axis lines
- On loadbang, send drawing commands:
  - "reset, glcolor 1 0 0 1, moveto 0 0 0, lineto 2 0 0" (X = red)
  - "glcolor 0 1 0 1, moveto 0 0 0, lineto 0 2 0" (Y = green)
  - "glcolor 0 0 1 1, moveto 0 0 0, lineto 0 0 2" (Z = blue)
  - End with "draw_now" to render the sketch

Camera (fixed, Claude's discretion per research recommendation):
- [jit.gl.camera myworld @position 3 2.5 3 @lookat 0 0 0]
- Fixed 3/4 angle provides clear view of all rotation axes

World:
- [jit.world myworld @enable 1 @fps 30 @size 400 400 @floating 1 @erase_color 0.15 0.15 0.15 1.0]
- @floating 1 creates a separate resizable window
- @fps 30 is sufficient for orientation visualization
- Dark background for contrast

ENABLE/DISABLE (prevents CPU waste when hidden -- Pitfall 6):
- Inside subpatcher: [loadbang] -> [1] -> [message "enable $1"] -> [jit.world myworld]
- [closebang] -> [0] -> [message "enable $1"] -> [jit.world myworld]
- This ensures jit.world stops rendering when the subpatcher window is closed

ROTATION WIRING:
- Receive smoothed orientation: [r smooth_pitch], [r smooth_roll], [r smooth_yaw]
- [pack f f f] -> send as rotatexyz to both arrow shapes
- The rotation order matters: pitch=X, roll=Y, yaw=Z maps to rotatexyz convention
- Test with physical board: tilting forward should pitch the arrow forward, rotating should yaw the arrow

NOTE: The arrow should point "up" (along Y or Z axis) at rest, so when the board is flat, the arrow points up. Tilting the board tilts the arrow. Adjust the initial shape orientation if needed so that the arrow's default pose corresponds to the board lying flat.
  </action>
  <verify>
Open sensor-pipeline.maxpat in MAX. Verify:
1. "Show 3D" button is visible in main patch
2. Clicking "Show 3D" opens a floating 3D window
3. Arrow shape is visible with colored tip/shaft against dark background
4. Ground plane grid and colored axis lines visible
5. Tilting the board rotates the arrow in matching direction
6. Rotating the board yaws the arrow correctly
7. Clicking "Hide 3D" closes the window
8. CPU does not stay elevated after closing the 3D window (check MAX CPU meter)
9. Re-opening the 3D view resumes rendering correctly
  </verify>
  <done>Hideable Jitter 3D visualization with arrow shape, ground grid, axis lines, fixed camera, and automatic enable/disable on open/close -- completing MAXI-06</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end hardware verification of all Phase 4 musical tools</name>
  <files>max/sensor-pipeline.maxpat</files>
  <action>
Human verification of ALL Phase 4 musical tools end-to-end with physical hardware. This checkpoint verifies Plans 01 + 02 + 03 working together.

**Setup:** Connect Arduino Uno WiFi R2 via USB. Open max/sensor-pipeline.maxpat in MAX. Verify node.script auto-starts and connects (status shows "connected", raw data flowing). Calibrate the sensor (click Calibrate, wait for auto-stop).

**Test 1: Smoothing (MAXI-01)**
1. With calibration active, observe the 9 smoothed data values -- they should match calibrated values (all dials at 1 = pass-through)
2. Turn the Global smoothing dial to ~15 -- all 9 smoothed values should become noticeably smoother
3. Turn it back to 1 -- output should match calibrated values exactly
4. Turn the Orient Group dial to ~10 -- only pitch/roll/yaw should smooth, accel and gyro unaffected
5. Turn a single per-axis dial (e.g., Pitch to ~20) -- only that axis should smooth further

**Test 2: Range Mapping (MAXI-02)**
6. In the pitch mapping module, click "Learn", tilt the board forward and back through your desired range, click "Stop"
7. Verify: In Min/In Max fields captured your movement range
8. Set Out Min=0, Out Max=127
9. Verify: mapped output moves within 0-127 as you tilt
10. Switch to Exponential mode -- response should feel curved (slow at bottom, fast at top)
11. Switch to Custom mode -- draw a curve in the function editor, verify it affects the mapping
12. Toggle Clip ON -- output should clamp to 0-127 range
13. Toggle Clip OFF -- output should be allowed to exceed 0-127

**Test 3: Thresholds (MAXI-03)**
14. With board level, slowly tilt forward past 30 degrees -- first pitch threshold should fire with "up" direction and button should flash
15. Tilt back below 30 degrees -- should fire with "down" direction
16. Tilt further past 60 degrees -- second threshold fires independently
17. Rapidly oscillate near 30 degrees -- hysteresis should prevent rapid firing (no buzzing)
18. Adjust hysteresis dial -- dead zone width should change

**Test 4: 3D Visualization (MAXI-06)**
19. Click "Show 3D" -- floating window appears with arrow on a grid
20. Verify: ground grid and colored XYZ axis lines visible
21. Tilt the board -- arrow tilts in matching direction
22. Rotate the board -- arrow rotates
23. Click "Hide 3D" -- window closes
24. Verify: CPU does not stay elevated after closing

**Test 5: Quaternion (MAXI-07)**
25. Check the 4 quaternion flonums (qX, qY, qZ, qW) are updating
26. With board flat: qW should be near 1.0, others near 0.0
27. Tilting should change quaternion values smoothly
  </action>
  <verify>All 5 test groups pass. All 5 Phase 4 success criteria met.</verify>
  <done>Phase 4 Musical Tools verified end-to-end with physical Arduino hardware: smoothing, mapping, thresholds, 3D viz, and quaternion all operational</done>
</task>

</tasks>

<verification>
- All 5 Phase 4 success criteria verified with physical hardware
- Smoothing: 13 dials, three-tier hierarchy, defaults to pass-through
- Mapping: 9 axes, 3 curve types, learn mode, clip toggle
- Thresholds: 6 axes, multiple thresholds per axis, hysteresis, direction output
- 3D viz: hideable, arrow shape, ground grid, axis lines, real-time orientation tracking
- Quaternion: 4 values displayed, normalized, updating in real time
- Zero changes to serial-bridge.js or imu_firmware.ino
</verification>

<success_criteria>
- MAXI-01: Smoothing operational with three-tier hierarchy
- MAXI-02: Range mapping with 3 curve types, learn mode, clip on all 9 axes
- MAXI-03: Threshold triggers with hysteresis and direction on 6 axes
- MAXI-06: 3D visualization with arrow, grid, axes, hideable
- MAXI-07: Quaternion output alongside Euler angles
- All verified end-to-end with physical Arduino hardware
</success_criteria>

<output>
After completion, create `.planning/phases/04-musical-tools/04-03-SUMMARY.md`
</output>
