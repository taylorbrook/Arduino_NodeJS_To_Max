---
phase: 08-custom-dtw-gesture-recognition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - max/gesture-engine.js
autonomous: true
requirements:
  - DTW-01
  - DTW-02
  - DTW-03
  - DTW-04
  - DTW-05
  - DTW-06
  - DTW-07
  - DTW-08
  - DTW-09
  - DTW-10

must_haves:
  truths:
    - "User can record a custom gesture via timed window or toggle mode and see recording progress"
    - "User can record 3-5 examples of the same gesture and system computes a representative template with null rejection stats"
    - "System matches incoming sensor data against stored templates at ~22Hz using DTW with Sakoe-Chiba band"
    - "DTW match outputs gesture name and 0.0-1.0 confidence via triggered and continuous outlets"
    - "Non-gesture motion is rejected via per-template null rejection thresholds"
    - "User can save gesture library to JSON and load it back with full recognition resuming"
    - "User can delete individual gesture templates"
    - "System auto-detects relevant axes from recorded examples with manual override available"
    - "DTW matching does not block the 114Hz sensor pipeline"
  artifacts:
    - path: "max/gesture-engine.js"
      provides: "DTW subsystem: recording, matching, templates, save/load, axis detection"
      contains: "dtwDistance"
      min_lines: 1200
  key_links:
    - from: "max/gesture-engine.js (processFrame)"
      to: "DTW matching scheduler"
      via: "decimation counter triggering scheduleDTWMatch"
      pattern: "dtwMatchCounter.*DTW_MATCH_EVERY"
    - from: "max/gesture-engine.js (DTW handlers)"
      to: "MAX outlets"
      via: "maxAPI.outlet for dtw_match, dtw_confidence, dtw_record_status, dtw_status"
      pattern: "maxAPI\\.outlet.*dtw_"
    - from: "max/gesture-engine.js (save/load)"
      to: "filesystem"
      via: "fs.writeFileSync/readFileSync for JSON library persistence"
      pattern: "fs\\.(write|read)FileSync"
---

<objective>
Add the complete DTW gesture recognition subsystem to gesture-engine.js: recording state machine with timed/toggle modes, multi-dimensional DTW algorithm with Sakoe-Chiba band, template management with best-representative selection, null rejection via training statistics, decimated real-time matching at ~22Hz, variance-based axis auto-detection, and JSON library save/load.

Purpose: This is the core algorithmic engine for custom gesture recognition. All DTW computation, template storage, and matching logic lives in gesture-engine.js as a subsystem alongside the existing predefined gesture detectors.
Output: gesture-engine.js extended from ~942 lines to ~1300-1400 lines with complete DTW capabilities.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-custom-dtw-gesture-recognition/08-RESEARCH.md
@.planning/phases/08-custom-dtw-gesture-recognition/08-CONTEXT.md
@.planning/phases/07-core-engine-and-predefined-gestures/07-01-SUMMARY.md
@max/gesture-engine.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DTW recording state machine, DTW algorithm, template management, and null rejection</name>
  <files>max/gesture-engine.js</files>
  <action>
Add the DTW subsystem to gesture-engine.js AFTER the existing predefined gesture detector code. All new code goes at the end of the file, before the final comment/closing. Use `var` declarations throughout (consistent with existing style).

**1. DTW State Variables** (add after existing gesture state):
```javascript
// === DTW SUBSYSTEM ===
var dtwSlots = {};           // slotId -> { name, label, enabled, threshold, cooldown, activeAxes, nullRejectionCoeff, bandRadius, lastFireTime, matchMode }
var dtwTemplates = {};       // slotId -> { template, examples, trainingMu, trainingSigma, rejectionThreshold, lastConfidence }
var dtwRecording = null;     // { slotId, buffer, mode, startTime, duration }
var dtwRecordState = "idle"; // "idle" | "recording" | "captured"
var dtwMatchCounter = 0;
var DTW_MATCH_EVERY = 5;     // ~22Hz at 114Hz input
var dtwMatchMode = "best";   // "best" or "all"
var dtwContinuousStream = false;
var dtwNextSlotId = 1;
var DTW_BUFFER_SIZE = 256;   // ~2.25s at 114Hz for DTW candidate window
var dtwBuffer = [];          // separate circular buffer for DTW (longer than gesture buffer)
var dtwBufferIndex = 0;
```

**2. DTW Circular Buffer** (separate from the 64-frame gesture buffer):
```javascript
function pushDTWFrame(frame) {
    if (dtwBuffer.length < DTW_BUFFER_SIZE) {
        dtwBuffer.push(frame);
    } else {
        dtwBuffer[dtwBufferIndex] = frame;
    }
    dtwBufferIndex = (dtwBufferIndex + 1) % DTW_BUFFER_SIZE;
}

function getDTWFrame(framesAgo) {
    if (framesAgo >= dtwBuffer.length) return null;
    var idx = (dtwBufferIndex - 1 - framesAgo + DTW_BUFFER_SIZE) % DTW_BUFFER_SIZE;
    return dtwBuffer[idx < 0 ? idx + DTW_BUFFER_SIZE : idx];
}

function getDTWWindow(length) {
    var window = [];
    var available = Math.min(length, dtwBuffer.length);
    for (var i = available - 1; i >= 0; i--) {
        var frame = getDTWFrame(i);
        if (frame) window.push(frame);
    }
    return window;
}
```

**3. Recording State Machine** (timed window + toggle modes per user decision):
```javascript
function startDTWRecording(slotId, mode, duration) {
    // Create slot if doesn't exist
    if (!dtwSlots[slotId]) {
        dtwSlots[slotId] = {
            name: "gesture-" + slotId,
            label: "",
            enabled: true,
            threshold: 0.6,
            cooldown: 500,
            activeAxes: ["ax","ay","az","gx","gy","gz"],
            nullRejectionCoeff: 3.0,
            bandRadius: 0.1,
            lastFireTime: 0,
            matchMode: "best"
        };
        dtwTemplates[slotId] = { template: null, examples: [], trainingMu: 0, trainingSigma: 0, rejectionThreshold: 0, lastConfidence: 0 };
    }
    dtwRecordState = "recording";
    dtwRecording = {
        slotId: slotId,
        buffer: [],
        mode: mode || "timed",
        startTime: Date.now(),
        duration: duration || 2000
    };
    maxAPI.outlet("dtw_record_status", "recording", slotId);
    maxAPI.post("[gesture-engine] DTW recording started for slot " + slotId + " (" + (mode || "timed") + ")");
}

function stopDTWRecording() {
    if (dtwRecordState !== "recording" || !dtwRecording) return;
    dtwRecordState = "captured";
    var example = dtwRecording.buffer.slice();
    var slotId = dtwRecording.slotId;
    addExampleToSlot(slotId, example);
    maxAPI.outlet("dtw_record_status", "captured", slotId, example.length);
    maxAPI.post("[gesture-engine] DTW recorded " + example.length + " frames for slot " + slotId +
                " (example " + dtwTemplates[slotId].examples.length + ")");
    dtwRecording = null;
    // Return to idle after a short delay (let MAX process the captured message)
    setTimeout(function() { dtwRecordState = "idle"; }, 100);
}

function recordDTWFrame(frame) {
    if (dtwRecordState !== "recording" || !dtwRecording) return;
    // Store frame as object with named axes for DTW matching
    var namedFrame = {
        ax: frame[0], ay: frame[1], az: frame[2],
        gx: frame[3], gy: frame[4], gz: frame[5],
        pitch: frame[6], roll: frame[7], yaw: frame[8]
    };
    // Add quaternion if available (13-field CSV)
    if (frame.length >= 13) {
        namedFrame.q0 = frame[9];
        namedFrame.q1 = frame[10];
        namedFrame.q2 = frame[11];
        namedFrame.q3 = frame[12];
    }
    dtwRecording.buffer.push(namedFrame);
    maxAPI.outlet("dtw_record_progress", dtwRecording.buffer.length);

    // Auto-stop for timed mode
    if (dtwRecording.mode === "timed" &&
        Date.now() - dtwRecording.startTime >= dtwRecording.duration) {
        stopDTWRecording();
    }
}
```

**4. Template Management with Best-Representative Selection**:
```javascript
function addExampleToSlot(slotId, example) {
    if (!dtwTemplates[slotId]) {
        dtwTemplates[slotId] = { template: null, examples: [], trainingMu: 0, trainingSigma: 0, rejectionThreshold: 0, lastConfidence: 0 };
    }
    dtwTemplates[slotId].examples.push(example);
    // Recompute template and stats if 2+ examples
    if (dtwTemplates[slotId].examples.length >= 2) {
        computeTemplateAndStats(slotId);
    } else {
        // With just 1 example, use it directly as template (no null rejection yet)
        dtwTemplates[slotId].template = example;
        dtwTemplates[slotId].rejectionThreshold = 0; // disabled until 2+ examples
    }
    maxAPI.outlet("dtw_slot_info", slotId, dtwSlots[slotId].name, dtwTemplates[slotId].examples.length);
}

function computeTemplateAndStats(slotId) {
    var examples = dtwTemplates[slotId].examples;
    if (examples.length < 2) return;

    var slot = dtwSlots[slotId];
    var axes = slot.activeAxes;
    var bandRadius = slot.bandRadius || 0.1;

    // Auto-detect axes if this is the first computation
    if (!slot._axesManuallySet) {
        var detected = autoDetectAxes(examples);
        slot.activeAxes = detected;
        axes = detected;
        maxAPI.outlet("dtw_axes_detected", slotId, axes.join(" "));
        maxAPI.post("[gesture-engine] Auto-detected axes for slot " + slotId + ": " + axes.join(","));
    }

    // Compute pairwise DTW distances
    var distances = [];
    var avgDistances = new Array(examples.length).fill(0);
    for (var i = 0; i < examples.length; i++) {
        for (var j = i + 1; j < examples.length; j++) {
            var d = dtwDistance(examples[i], examples[j], axes, bandRadius);
            distances.push(d);
            avgDistances[i] += d;
            avgDistances[j] += d;
        }
    }

    // Select best representative (lowest average distance to all others)
    for (var i = 0; i < avgDistances.length; i++) {
        avgDistances[i] /= (examples.length - 1);
    }
    var bestIdx = 0;
    var bestDist = avgDistances[0];
    for (var i = 1; i < avgDistances.length; i++) {
        if (avgDistances[i] < bestDist) {
            bestDist = avgDistances[i];
            bestIdx = i;
        }
    }
    dtwTemplates[slotId].template = examples[bestIdx];

    // Compute training statistics for null rejection
    var mu = 0;
    for (var i = 0; i < distances.length; i++) mu += distances[i];
    mu /= distances.length;

    var variance = 0;
    for (var i = 0; i < distances.length; i++) {
        variance += (distances[i] - mu) * (distances[i] - mu);
    }
    variance /= distances.length;
    var sigma = Math.sqrt(variance);

    dtwTemplates[slotId].trainingMu = mu;
    dtwTemplates[slotId].trainingSigma = sigma;
    // With exactly 2 examples, sigma may be very small -- use wider coefficient
    var coeff = examples.length <= 2 ? 5.0 : (slot.nullRejectionCoeff || 3.0);
    dtwTemplates[slotId].rejectionThreshold = mu + coeff * sigma;

    maxAPI.post("[gesture-engine] Slot " + slotId + " template computed: mu=" +
                mu.toFixed(3) + " sigma=" + sigma.toFixed(3) +
                " threshold=" + dtwTemplates[slotId].rejectionThreshold.toFixed(3));
}
```

**5. Multi-Dimensional DTW with Sakoe-Chiba Band** (core algorithm, ~40 lines):
```javascript
function dtwDistance(seq1, seq2, activeAxes, bandRadius) {
    var n = seq1.length;
    var m = seq2.length;
    var band = Math.max(1, Math.round(bandRadius * Math.max(n, m)));

    // Initialize cost matrix with Infinity
    var cost = [];
    for (var i = 0; i <= n; i++) {
        cost[i] = new Array(m + 1).fill(Infinity);
    }
    cost[0][0] = 0;

    for (var i = 1; i <= n; i++) {
        var jCenter = Math.round(i * m / n);
        var jStart = Math.max(1, jCenter - band);
        var jEnd = Math.min(m, jCenter + band);

        for (var j = jStart; j <= jEnd; j++) {
            // Multi-dimensional Euclidean distance
            var d = 0;
            for (var k = 0; k < activeAxes.length; k++) {
                var axis = activeAxes[k];
                var v1 = seq1[i - 1][axis] || 0;
                var v2 = seq2[j - 1][axis] || 0;
                var diff = v1 - v2;
                d += diff * diff;
            }
            d = Math.sqrt(d);

            cost[i][j] = d + Math.min(
                cost[i - 1][j],
                cost[i][j - 1],
                cost[i - 1][j - 1]
            );
        }
    }

    // Normalize by path length
    return cost[n][m] / (n + m);
}
```

**6. Variance-Based Axis Auto-Detection** (per research Pattern 7):
```javascript
function autoDetectAxes(examples) {
    var allAxes = ["ax","ay","az","gx","gy","gz","pitch","roll","yaw","q0","q1","q2","q3"];
    var variances = {};

    allAxes.forEach(function(axis) {
        var values = [];
        examples.forEach(function(ex) {
            ex.forEach(function(frame) {
                if (frame[axis] !== undefined) values.push(frame[axis]);
            });
        });
        if (values.length === 0) { variances[axis] = 0; return; }

        var mean = 0;
        for (var i = 0; i < values.length; i++) mean += values[i];
        mean /= values.length;

        var v = 0;
        for (var i = 0; i < values.length; i++) {
            v += (values[i] - mean) * (values[i] - mean);
        }
        variances[axis] = v / values.length;
    });

    var maxVar = 0;
    var keys = Object.keys(variances);
    for (var i = 0; i < keys.length; i++) {
        if (variances[keys[i]] > maxVar) maxVar = variances[keys[i]];
    }
    var threshold = maxVar * 0.1;

    var selected = allAxes.filter(function(axis) {
        return variances[axis] > threshold;
    });

    // Ensure at least 3 axes
    if (selected.length < 3) {
        var sorted = allAxes.slice().sort(function(a, b) {
            return (variances[b] || 0) - (variances[a] || 0);
        });
        selected = sorted.slice(0, 3);
    }

    return selected;
}
```

**7. Decimated Real-Time Matching with setImmediate Yield** (per research Pattern 5):
```javascript
var dtwPendingResults = {};

function scheduleDTWMatch() {
    var slotIds = Object.keys(dtwSlots).filter(function(id) {
        return dtwSlots[id].enabled && dtwTemplates[id] && dtwTemplates[id].template;
    });
    if (slotIds.length === 0) return;

    // Get candidate window from DTW buffer
    // Use window sized to ~1.5x the longest template
    var maxLen = 0;
    for (var i = 0; i < slotIds.length; i++) {
        var tLen = dtwTemplates[slotIds[i]].template.length;
        if (tLen > maxLen) maxLen = tLen;
    }
    var windowSize = Math.min(DTW_BUFFER_SIZE, Math.round(maxLen * 1.5));
    var candidate = getDTWWindow(windowSize);
    if (candidate.length < 20) return; // not enough data

    // Convert candidate frames to named-axis objects (DTW buffer stores calibrated arrays)
    var namedCandidate = candidate.map(function(frame) {
        var obj = {
            ax: frame[0], ay: frame[1], az: frame[2],
            gx: frame[3], gy: frame[4], gz: frame[5],
            pitch: frame[6], roll: frame[7], yaw: frame[8]
        };
        if (frame.length >= 13) {
            obj.q0 = frame[9]; obj.q1 = frame[10];
            obj.q2 = frame[11]; obj.q3 = frame[12];
        }
        return obj;
    });

    dtwPendingResults = {};
    var startTime = Date.now();
    processNextTemplate(slotIds, 0, namedCandidate, startTime);
}

function processNextTemplate(slotIds, idx, candidate, startTime) {
    if (idx >= slotIds.length) {
        emitDTWResults();
        // Performance guard
        var elapsed = Date.now() - startTime;
        if (elapsed > 20) {
            maxAPI.post("[gesture-engine] DTW cycle took " + elapsed + "ms -- consider reducing gesture count");
        }
        return;
    }

    var slotId = slotIds[idx];
    var template = dtwTemplates[slotId].template;
    var axes = dtwSlots[slotId].activeAxes;
    var bandRadius = dtwSlots[slotId].bandRadius || 0.1;

    // Check length ratio -- skip if too extreme (>3:1)
    var ratio = candidate.length / template.length;
    if (ratio > 3 || ratio < 0.33) {
        dtwPendingResults[slotId] = 0;
        setImmediate(function() { processNextTemplate(slotIds, idx + 1, candidate, startTime); });
        return;
    }

    var distance = dtwDistance(candidate, template, axes, bandRadius);
    var threshold = dtwTemplates[slotId].rejectionThreshold;

    var confidence;
    if (threshold <= 0) {
        // No rejection threshold (single example) -- use raw distance inverse
        confidence = Math.max(0, 1.0 - distance / 2.0);
    } else {
        confidence = threshold > 0 ? Math.max(0, 1.0 - distance / threshold) : 0;
    }

    dtwPendingResults[slotId] = confidence;
    dtwTemplates[slotId].lastConfidence = confidence;

    // Yield to event loop between templates
    setImmediate(function() {
        processNextTemplate(slotIds, idx + 1, candidate, startTime);
    });
}

function emitDTWResults() {
    var now = Date.now();
    var bestSlot = null;
    var bestConf = 0;

    var slotIds = Object.keys(dtwPendingResults);
    for (var i = 0; i < slotIds.length; i++) {
        var slotId = slotIds[i];
        var conf = dtwPendingResults[slotId];
        var slot = dtwSlots[slotId];

        // Continuous confidence stream (if enabled)
        if (dtwContinuousStream) {
            maxAPI.outlet("dtw_confidence", slotId, slot.name, conf.toFixed(3));
        }

        // Check if above user threshold and not in cooldown
        if (conf >= slot.threshold && (now - slot.lastFireTime) >= slot.cooldown) {
            if (dtwMatchMode === "all") {
                // Fire all above threshold
                maxAPI.outlet("dtw_match", slot.name, conf.toFixed(3));
                slot.lastFireTime = now;
            } else {
                // Track best
                if (conf > bestConf) {
                    bestConf = conf;
                    bestSlot = slotId;
                }
            }
        }
    }

    // In "best" mode, fire only the best match
    if (dtwMatchMode === "best" && bestSlot !== null) {
        var slot = dtwSlots[bestSlot];
        maxAPI.outlet("dtw_match", slot.name, bestConf.toFixed(3));
        slot.lastFireTime = now;
    }
}
```

**8. Save/Load Handlers** (per research Pattern 6):
```javascript
var fs = require("fs");

maxAPI.addHandler("dtw_save", function(filepath) {
    var library = {
        version: 1,
        created: new Date().toISOString(),
        description: "",
        slots: {}
    };

    Object.keys(dtwSlots).forEach(function(id) {
        library.slots[id] = {
            name: dtwSlots[id].name,
            label: dtwSlots[id].label,
            enabled: dtwSlots[id].enabled,
            threshold: dtwSlots[id].threshold,
            cooldown: dtwSlots[id].cooldown,
            activeAxes: dtwSlots[id].activeAxes,
            nullRejectionCoeff: dtwSlots[id].nullRejectionCoeff,
            bandRadius: dtwSlots[id].bandRadius,
            template: dtwTemplates[id] ? dtwTemplates[id].template : null,
            examples: dtwTemplates[id] ? dtwTemplates[id].examples : [],
            trainingMu: dtwTemplates[id] ? dtwTemplates[id].trainingMu : 0,
            trainingSigma: dtwTemplates[id] ? dtwTemplates[id].trainingSigma : 0,
            rejectionThreshold: dtwTemplates[id] ? dtwTemplates[id].rejectionThreshold : 0
        };
    });

    // Truncate template values to 3 decimal places for file size reduction
    var json = JSON.stringify(library, function(key, val) {
        return typeof val === "number" ? Math.round(val * 1000) / 1000 : val;
    }, 2);

    fs.writeFileSync(filepath, json);
    maxAPI.outlet("dtw_status", "saved", filepath);
    maxAPI.post("[gesture-engine] DTW library saved to " + filepath);
});

maxAPI.addHandler("dtw_load", function(filepath) {
    try {
        var data = JSON.parse(fs.readFileSync(filepath, "utf8"));
        if (data.version !== 1) {
            maxAPI.post("[gesture-engine] Unsupported library version: " + data.version);
            return;
        }
        dtwSlots = {};
        dtwTemplates = {};
        dtwNextSlotId = 1;
        Object.keys(data.slots).forEach(function(id) {
            var s = data.slots[id];
            dtwSlots[id] = {
                name: s.name, label: s.label || "", enabled: s.enabled,
                threshold: s.threshold, cooldown: s.cooldown,
                activeAxes: s.activeAxes,
                nullRejectionCoeff: s.nullRejectionCoeff || 3.0,
                bandRadius: s.bandRadius || 0.1,
                lastFireTime: 0, matchMode: "best",
                _axesManuallySet: true  // loaded axes are intentional
            };
            dtwTemplates[id] = {
                template: s.template, examples: s.examples || [],
                trainingMu: s.trainingMu || 0, trainingSigma: s.trainingSigma || 0,
                rejectionThreshold: s.rejectionThreshold || 0,
                lastConfidence: 0
            };
            var numId = parseInt(id);
            if (numId >= dtwNextSlotId) dtwNextSlotId = numId + 1;
        });
        maxAPI.outlet("dtw_status", "loaded", filepath);
        maxAPI.outlet("dtw_library_info", Object.keys(dtwSlots).length);
        maxAPI.post("[gesture-engine] DTW library loaded: " + Object.keys(dtwSlots).length + " gestures from " + filepath);
    } catch (e) {
        maxAPI.post("[gesture-engine] Load error: " + e.message);
        maxAPI.outlet("dtw_status", "error", e.message);
    }
});
```

**9. All remaining MAX handlers** for DTW control:
```javascript
maxAPI.addHandler("dtw_record_start", function(slotId, mode, duration) {
    if (!slotId) slotId = dtwNextSlotId;
    startDTWRecording(slotId, mode || "timed", duration || 2000);
});

maxAPI.addHandler("dtw_record_stop", function() {
    stopDTWRecording();
});

maxAPI.addHandler("dtw_delete", function(slotId) {
    if (dtwSlots[slotId]) {
        delete dtwSlots[slotId];
        delete dtwTemplates[slotId];
        maxAPI.outlet("dtw_status", "deleted", slotId);
        maxAPI.post("[gesture-engine] Deleted DTW slot " + slotId);
    }
});

maxAPI.addHandler("dtw_enable", function(slotId, enabled) {
    if (dtwSlots[slotId]) {
        dtwSlots[slotId].enabled = enabled ? true : false;
    }
});

maxAPI.addHandler("dtw_threshold", function(slotId, value) {
    if (dtwSlots[slotId]) {
        dtwSlots[slotId].threshold = parseFloat(value) || 0.6;
    }
});

maxAPI.addHandler("dtw_cooldown", function(slotId, value) {
    if (dtwSlots[slotId]) {
        dtwSlots[slotId].cooldown = parseInt(value) || 500;
    }
});

maxAPI.addHandler("dtw_name", function(slotId, name) {
    if (dtwSlots[slotId]) {
        dtwSlots[slotId].name = name || ("gesture-" + slotId);
    }
});

maxAPI.addHandler("dtw_label", function(slotId, label) {
    if (dtwSlots[slotId]) {
        dtwSlots[slotId].label = label || "";
    }
});

maxAPI.addHandler("dtw_axes", function(slotId) {
    // Remaining args are axis names
    if (dtwSlots[slotId]) {
        var axes = Array.prototype.slice.call(arguments, 1);
        if (axes.length > 0) {
            dtwSlots[slotId].activeAxes = axes;
            dtwSlots[slotId]._axesManuallySet = true;
        }
    }
});

maxAPI.addHandler("dtw_axes_auto", function(slotId) {
    if (dtwSlots[slotId] && dtwTemplates[slotId] && dtwTemplates[slotId].examples.length > 0) {
        dtwSlots[slotId]._axesManuallySet = false;
        var detected = autoDetectAxes(dtwTemplates[slotId].examples);
        dtwSlots[slotId].activeAxes = detected;
        maxAPI.outlet("dtw_axes_detected", slotId, detected.join(" "));
    }
});

maxAPI.addHandler("dtw_match_mode", function(mode) {
    if (mode === "best" || mode === "all") {
        dtwMatchMode = mode;
        maxAPI.post("[gesture-engine] DTW match mode: " + mode);
    }
});

maxAPI.addHandler("dtw_continuous", function(enabled) {
    dtwContinuousStream = enabled ? true : false;
});

maxAPI.addHandler("dtw_record_duration", function(ms) {
    // Sets default duration for next timed recording
    if (dtwRecording && dtwRecording.mode === "timed") {
        dtwRecording.duration = parseInt(ms) || 2000;
    }
});

maxAPI.addHandler("dtw_null_rejection_coeff", function(slotId, coeff) {
    if (dtwSlots[slotId]) {
        dtwSlots[slotId].nullRejectionCoeff = parseFloat(coeff) || 3.0;
        // Recompute threshold if we have stats
        if (dtwTemplates[slotId] && dtwTemplates[slotId].examples.length >= 2) {
            computeTemplateAndStats(slotId);
        }
    }
});

maxAPI.addHandler("dtw_clear_all", function() {
    dtwSlots = {};
    dtwTemplates = {};
    dtwNextSlotId = 1;
    maxAPI.outlet("dtw_status", "cleared");
    maxAPI.post("[gesture-engine] All DTW slots cleared");
});
```

**10. Update processFrame()** to integrate DTW:
Find the existing `processFrame` function. After the line that calls predefined gesture detectors (after `detectTilts(...)` call), add:

```javascript
// Push calibrated frame to DTW buffer
pushDTWFrame(calValues);

// Record DTW frame if recording active
if (dtwRecordState === "recording") {
    recordDTWFrame(calValues);
}

// Decimated DTW matching
dtwMatchCounter++;
if (dtwMatchCounter >= DTW_MATCH_EVERY) {
    dtwMatchCounter = 0;
    if (dtwRecordState === "idle") {
        scheduleDTWMatch();
    }
}
```

Where `calValues` is the calibrated values array (the same array used by predefined gesture detectors). Make sure to use the correct variable name from the existing processFrame code.

**11. Update CSV validation** to accept 13-field lines (quaternion):
Find the existing line validation in gesture-engine.js. Update `EXPECTED_FIELDS = 9` (or whatever the constant is named) to accept 9-13 fields:
```javascript
var EXPECTED_FIELDS_MIN = 9;
var EXPECTED_FIELDS_MAX = 13;
```
Update the validation check accordingly. If there's a `parts.length !== EXPECTED_FIELDS` check, change it to `parts.length < EXPECTED_FIELDS_MIN || parts.length > EXPECTED_FIELDS_MAX`.

Also output quaternion data when present:
```javascript
if (values.length >= 13) {
    maxAPI.outlet("quaternion", values[9], values[10], values[11], values[12]);
}
```

IMPORTANT NOTES:
- Use `var` for ALL declarations (NOT `let` or `const`) -- consistent with existing gesture-engine.js style
- Add `var fs = require("fs");` near the top of the file with other requires
- Do NOT use ES6 features (arrow functions, template literals, destructuring) -- the existing code uses ES5 throughout
- Do NOT use `Array.from`, `Object.values`, `Object.entries`, or other ES6+ methods -- use `Object.keys` + indexing
- Ensure `setImmediate` is used for async yielding. If it's not available (tested by the executor), fall back to `setTimeout(fn, 0)`.
- The DTW buffer (`dtwBuffer`) is separate from the existing 64-frame gesture buffer. Both get frames pushed in processFrame.
  </action>
  <verify>
1. Read max/gesture-engine.js and confirm all DTW functions exist: dtwDistance, startDTWRecording, stopDTWRecording, recordDTWFrame, addExampleToSlot, computeTemplateAndStats, autoDetectAxes, scheduleDTWMatch, processNextTemplate, emitDTWResults
2. Confirm all MAX handlers registered: dtw_record_start, dtw_record_stop, dtw_save, dtw_load, dtw_delete, dtw_enable, dtw_threshold, dtw_cooldown, dtw_name, dtw_label, dtw_axes, dtw_axes_auto, dtw_match_mode, dtw_continuous, dtw_clear_all, dtw_null_rejection_coeff, dtw_record_duration
3. Confirm processFrame calls pushDTWFrame, recordDTWFrame, and scheduleDTWMatch
4. Count lines: should be ~1200-1400 lines total
5. Verify no ES6 syntax (grep for `const `, `let `, `=>`, backtick)
  </verify>
  <done>gesture-engine.js contains complete DTW subsystem: recording (timed/toggle), DTW algorithm with Sakoe-Chiba band, best-representative template selection, null rejection via training stats, ~22Hz decimated matching with setImmediate yield, variance-based axis auto-detection, JSON save/load, and all DTW MAX handlers.</done>
</task>

</tasks>

<verification>
1. gesture-engine.js has all DTW functions and handlers
2. DTW matching is decimated (every 5th frame) with setImmediate yield
3. Save/load uses JSON format with version field and all slot metadata
4. Null rejection uses per-template threshold computed from training statistics
5. Axis auto-detection analyzes variance across all available axes
6. Recording state machine supports both timed and toggle modes
7. All code uses `var` declarations and ES5 compatible syntax
8. processFrame integrates DTW buffer, recording, and matching
</verification>

<success_criteria>
- gesture-engine.js contains working DTW subsystem (~1200-1400 lines total)
- All 17 DTW handler messages are registered
- DTW distance function implements Sakoe-Chiba band constraint
- Template management computes best representative from multiple examples
- Null rejection threshold follows GRT formula: mu + coeff * sigma
- Save/load produces valid JSON with all gesture metadata
- Matching runs at ~22Hz without blocking 114Hz sensor pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/08-custom-dtw-gesture-recognition/08-02-SUMMARY.md`
</output>
