---
phase: 05-abstraction-wifi
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - max/imu-sensor.maxhelp
autonomous: false

must_haves:
  truths:
    - "A help patch opens when user right-clicks the [imu-sensor] object and selects Help"
    - "Help patch documents every inlet, outlet, argument, and @attribute with explanatory comment boxes"
    - "Built-in test signal simulates realistic sensor data so the help patch works without hardware"
    - "Three creative recipe examples demonstrate different use cases: continuous control, discrete triggers, and spatial audio"
    - "Help patch works standalone without an Arduino connected (via test signal)"
  artifacts:
    - path: "max/imu-sensor.maxhelp"
      provides: "Auto-discovered help patch for the imu-sensor abstraction"
      contains: "imu-sensor"
  key_links:
    - from: "max/imu-sensor.maxhelp"
      to: "max/imu-sensor.maxpat"
      via: "Same basename -- MAX auto-discovers .maxhelp files"
      pattern: "imu-sensor"
---

<objective>
Create the help patch (imu-sensor.maxhelp) that documents the abstraction and provides working examples. Includes a built-in test signal generator, annotated documentation of all inlets/outlets/arguments, and three creative recipe examples showcasing different use cases.

Purpose: Users can learn the abstraction's full API and see creative applications without hardware. The help patch serves as both documentation and inspiration.

Output: imu-sensor.maxhelp file with documentation, test signal, and 3 recipe examples.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-abstraction-wifi/05-RESEARCH.md
@.planning/phases/05-abstraction-wifi/05-CONTEXT.md
@.planning/phases/05-abstraction-wifi/05-02-SUMMARY.md
@max/imu-sensor.maxpat
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create imu-sensor.maxhelp with documentation, test signal, and recipe examples</name>
  <files>max/imu-sensor.maxhelp</files>
  <action>
  Create `max/imu-sensor.maxhelp` as a comprehensive help patch. The file format is identical to .maxpat (MAX JSON) -- only the extension differs. MAX auto-discovers help files with the same basename.

  **Layout sections (top to bottom):**

  ### Section 1: Title and Overview
  - Large comment box: "imu-sensor -- IMU Sensor Pipeline for Arduino Uno WiFi R2"
  - Subtitle comment: "Reads accelerometer + gyroscope data via USB or WiFi, with calibration, smoothing, mapping, quaternion output, and threshold triggers"
  - Comment listing all arguments: "Arguments: port_name (optional) | Attributes: @smooth, @transport, @ip, @udpport"

  ### Section 2: Basic Usage
  - An [imu-sensor] object instance with no arguments (for test signal mode)
  - Comment boxes labeling each outlet:
    ```
    outlet 0: status (symbol: connected-usb, connected-wifi, switching, disconnected)
    outlet 1: raw_accel (3 floats: ax ay az, range -2..2 g)
    outlet 2: raw_gyro (3 floats: gx gy gz, range -250..250 dps)
    outlet 3: raw_orientation (3 floats: pitch roll yaw, degrees)
    outlet 4: cal_accel (3 floats: calibrated ax ay az)
    outlet 5: cal_gyro (3 floats: calibrated gx gy gz)
    outlet 6: cal_orientation (3 floats: calibrated pitch roll yaw)
    outlet 7: smooth_accel (3 floats: smoothed ax ay az)
    outlet 8: smooth_gyro (3 floats: smoothed gx gy gz)
    outlet 9: smooth_orientation (3 floats: smoothed pitch roll yaw)
    outlet 10: mapped (tagged: axis_name value, e.g., "pitch 0.72")
    outlet 11: quaternion (4 floats: qX qY qZ qW)
    outlet 12: triggers (tagged: axis_name bang/direction)
    ```
  - [print] objects connected to each outlet for visibility
  - Comment: "Inlet: control messages (see Message Reference below)"

  ### Section 3: Message Reference
  - Comment box listing all accepted messages with examples:
    ```
    -- Transport --
    transport usb          Switch to USB serial
    transport wifi         Switch to WiFi UDP
    transport auto         Try USB, fall back to WiFi

    -- Connection --
    connect                Auto-scan for Arduino
    connect /dev/tty.xxx   Connect to specific port
    disconnect             Stop all transports

    -- Calibration --
    calibrate              Start/toggle calibration
    orient_reset           Zero orientation
    orient_restore         Restore original orientation

    -- Smoothing --
    smoothing global 0.5        Set global smoothing (0.0-1.0)
    smoothing accel_group 0.3   Set group smoothing
    smoothing pitch 0.7         Set per-axis smoothing

    -- Thresholds --
    threshold pitch 45          Set threshold angle
    threshold pitch 45 hysteresis 5

    -- Mapping --
    mapping pitch inrange 0 90
    mapping pitch outrange 0 1
    mapping pitch curve exponential

    -- WiFi --
    ip 192.168.1.50        Set Arduino IP
    udpport 8889           Set UDP listen port
    ```
  - Message boxes for each example that users can click to send

  ### Section 4: Test Signal Generator
  Build a test signal that generates simulated sensor data matching real ranges:

  ```
  [toggle "Simulate Sensor Data"]
    |
  [metro 9]  -- ~111 Hz, close to real 114 Hz sample rate
    |
  [counter 0 3600]
    |
  [* 0.1]  -- slow counter in degrees
    |
  -- Generate realistic fake data for all 9 axes:

  Accelerometer (range: -2..2 g):
  [sin ($f1 * 0.05)] * 1.5   -- slow gentle tilt (ax)
  [cos ($f1 * 0.03)] * 0.5   -- cross-axis (ay)
  1.0 + [sin ($f1 * 0.02)] * 0.3  -- gravity + small variation (az)

  Gyroscope (range: -250..250 dps):
  [sin ($f1 * 0.08)] * 50    -- moderate rotation rate (gx)
  [cos ($f1 * 0.06)] * 30    -- (gy)
  [sin ($f1 * 0.04)] * 20    -- (gz)

  Orientation (degrees):
  [sin ($f1 * 0.03)] * 45 + 45   -- pitch 0-90
  [cos ($f1 * 0.02)] * 45 + 45   -- roll 0-90
  ($f1 * 0.5) % 360              -- yaw 0-360 slow rotation
  ```

  The test signal sends a `simulate_data` message to the abstraction's inlet, which the Node script interprets as synthetic sensor input (bypassing serial/UDP). Alternatively, if the abstraction doesn't have a simulate handler, generate the test signal in MAX and send it directly to the outlet print objects to demonstrate what real data looks like. Use the simpler approach: have the test signal generate values and display them alongside the abstraction's outlets for comparison.

  **Implementation approach for test signal:** Add a `simulate` handler to the route inside imu-sensor.maxpat OR generate the test data purely in the help patch using MAX objects (cycle~, counter, expr, etc.) and display it as "expected output" alongside the real outputs. The simplest approach that works without modifying serial-bridge.js: use MAX math objects in the help patch to generate fake 9-value lists, then format them as messages that look like the real outlet data. Add a comment: "Test signal generates simulated sensor data -- no hardware required."

  ### Section 5: Recipe 1 -- Tilt-to-Filter (Continuous Control)
  Demonstrate mapping pitch to filter cutoff and roll to resonance:

  ```
  [imu-sensor @smooth 0.5]
    |  (outlet 9: smooth_orientation)
    |
  [unpack f f f]
    |         |
  pitch      roll
    |         |
  [scale 0. 90. 200. 5000.]   [scale 0. 90. 0.1 10.]
    |                            |
  filter_cutoff                resonance
    |                            |
  [comment: "Connect to svf~ cutoff inlet"]  [comment: "Connect to svf~ Q inlet"]
  ```

  Add comment boxes explaining:
  - "Pitch (tilting forward/back) controls filter cutoff frequency"
  - "Roll (tilting left/right) controls filter resonance"
  - "Adjust scale ranges to taste"
  - "Works with any filter: svf~, lores~, biquad~"

  ### Section 6: Recipe 2 -- Gesture Triggers (Discrete Events)
  Demonstrate threshold-based triggering:

  ```
  [imu-sensor @smooth 0.3]
    |  (outlet 12: triggers)
    |
  [route pitch ax]
    |         |
  [comment: "Fires when pitch crosses 45 degrees"]
    |
  [message note 60 127]  -- MIDI note
    |
  [comment: "Connect to noteout or synth"]

  -- Shake detection from accelerometer:
    |  (outlet 7: smooth_accel)
    |
  [unpack f f f]
    |
  [abs]  -- absolute value of ax
    |
  [> 1.5]  -- threshold: acceleration > 1.5g
    |
  [change]  -- only trigger on state change
    |
  [sel 1]
    |
  [comment: "Fires on sharp horizontal shake"]
  ```

  Add comment boxes explaining:
  - "threshold message sets the crossing point for orientation triggers"
  - "For acceleration-based triggers, use abs + comparison in MAX"
  - "change object prevents repeated triggers while threshold is held"

  ### Section 7: Recipe 3 -- Spatial Panning (3D Audio)
  Demonstrate yaw-controlled stereo panning:

  ```
  [imu-sensor @smooth 0.7]
    |  (outlet 9: smooth_orientation)
    |
  [unpack f f f]
    |         |    |
  pitch      roll  yaw
                    |
  [scale 0. 360. -1. 1.]  -- yaw to pan position (-1=left, 1=right)
    |
  [comment: "Connect to pan~ or M4L panning device"]

  -- OR use quaternion for rotation-aware spatialization:
    |  (outlet 11: quaternion)
    |
  [unpack f f f f]
    |
  [comment: "qX qY qZ qW -- use for ambisonics or VBAP"]
  ```

  Add comment boxes explaining:
  - "Yaw (rotation left/right) maps naturally to stereo pan"
  - "For full 3D spatialization, use the quaternion outlet with ambisonics tools"
  - "Higher smoothing (0.7) reduces jitter for smooth panning"

  ### Section 8: Configuration Examples
  Message boxes showing common configurations:

  ```
  [message transport usb]     -- "USB mode (default)"
  [message transport wifi]    -- "WiFi mode"
  [message smoothing global 0.5] -- "Medium smoothing"
  [message calibrate]         -- "Start calibration (hold board still)"
  [message orient_reset]      -- "Zero current orientation"
  ```

  IMPORTANT: All comment boxes should use annotated style -- explain not just what things do but WHY you would use them in a musical context.

  IMPORTANT: The .maxhelp file uses the exact same JSON format as .maxpat files. Only the extension differs.
  </action>
  <verify>
  Check that max/imu-sensor.maxhelp:
  - Is valid JSON (same format as .maxpat)
  - Contains at least one [imu-sensor] object instance
  - Contains comment boxes documenting all outlets
  - Contains message reference section with clickable message boxes
  - Contains test signal generator with toggle/metro
  - Contains 3 recipe sections (tilt-to-filter, gesture triggers, spatial panning)
  - Has the same basename as imu-sensor.maxpat (MAX auto-discovery)
  </verify>
  <done>imu-sensor.maxhelp is a comprehensive help patch with outlet documentation, message reference, test signal generator, and 3 creative recipe examples. It works without hardware via the test signal. MAX auto-discovers it via same-name convention.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify abstraction, WiFi, help patch, and 3D viz in MAX</name>
  <files>max/imu-sensor.maxpat, max/imu-sensor.maxhelp, max/imu-sensor-3dviz.maxpat</files>
  <action>
  Human verification checkpoint for the complete Phase 5 deliverables:
  1. imu-sensor.maxpat -- drop-in abstraction with 13 outlets, message control, transport dropdown
  2. imu-sensor.maxhelp -- help patch with documentation, test signal, 3 recipes
  3. imu-sensor-3dviz.maxpat -- companion 3D visualization
  4. Updated imu_firmware.ino -- dual-mode WiFi+USB firmware
  5. Updated serial-bridge.js -- UDP listener + transport switching

  **Step 1: Basic abstraction test**
  1. Open MAX/MSP
  2. Add the `max/` directory to MAX's File Preferences search path (if not already)
  3. Create a new empty patch
  4. Create object: `[imu-sensor]` (no arguments)
  5. Verify it loads without errors in the Max console
  6. Right-click the object -> select "Open Help" -> verify the help patch opens

  **Step 2: Help patch test signal**
  1. In the help patch, find the test signal section
  2. Enable the test signal toggle
  3. Verify simulated sensor values appear in the print objects / number boxes
  4. Verify the three recipe examples are clearly documented with comment boxes

  **Step 3: USB connection test (with hardware)**
  1. Connect Arduino Uno WiFi R2 via USB
  2. In a new patch, create: `[imu-sensor /dev/tty.usbmodemXXXX]` (use your actual port)
  3. Connect print objects to outlets 0-12
  4. Verify status outlet shows "connected-usb"
  5. Verify raw sensor data appears on outlets 1-3
  6. Send message `smoothing global 0.5` to inlet -> verify smoothed data changes on outlets 7-9
  7. Send message `calibrate` to inlet -> verify calibration runs

  **Step 4: 3D visualization test**
  1. Open imu-sensor-3dviz.maxpat
  2. Connect it to the imu-sensor abstraction's smooth_orientation outlet (outlet 9)
  3. Enable the 3D view toggle
  4. Tilt the Arduino board -> verify the 3D shape rotates to match

  **Step 5: WiFi test (if WiFi firmware uploaded)**
  1. Upload updated firmware to Arduino (with arduino_secrets.h configured)
  2. Send message `transport wifi` to the abstraction inlet
  3. Verify status changes to "connected-wifi"
  4. Verify sensor data still flows through all outlets
  5. Send `transport usb` -> verify it switches back cleanly
  </action>
  <verify>User types "approved" or describes issues to fix</verify>
  <done>All Phase 5 deliverables verified working in MAX: abstraction loads, help patch opens, test signal runs, USB data flows, 3D viz renders, WiFi transport switches correctly</done>
</task>

</tasks>

<verification>
1. max/imu-sensor.maxhelp exists and is valid JSON
2. Right-clicking [imu-sensor] in MAX opens the help patch
3. Test signal generates simulated data without hardware
4. Three recipe examples are documented with annotated comments
5. All outlets are documented with purpose and data format
6. Message reference covers all control messages
7. Help patch includes configuration examples with clickable message boxes
</verification>

<success_criteria>
- Help patch auto-opens from [imu-sensor] object via MAX's help file convention
- Documentation covers every inlet, outlet, argument, and @attribute
- Test signal works without hardware and produces realistic sensor-range values
- Three recipes demonstrate continuous control, discrete triggers, and spatial audio
- User verifies end-to-end functionality with hardware (if available)
</success_criteria>

<output>
After completion, create `.planning/phases/05-abstraction-wifi/05-03-SUMMARY.md`
</output>
