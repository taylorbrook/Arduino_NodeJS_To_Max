---
phase: 05-abstraction-wifi
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - firmware/imu_firmware/imu_firmware.ino
  - firmware/imu_firmware/arduino_secrets.h.example
  - node/serial-bridge.js
autonomous: true

must_haves:
  truths:
    - "Arduino firmware sends IMU CSV data over WiFi UDP in addition to USB serial without degrading the 114 Hz USB loop rate"
    - "Node for Max serial-bridge.js can receive IMU data via UDP socket (dgram) and route it through the same validation/calibration/smoothing pipeline as USB"
    - "User can switch transport between usb, wifi, and auto modes via message handler in Node"
    - "Status outlet reports transport-aware states: connected-usb, connected-wifi, switching, disconnected"
  artifacts:
    - path: "firmware/imu_firmware/imu_firmware.ino"
      provides: "Dual-mode firmware with WiFiNINA UDP send alongside USB serial"
      contains: "WiFiNINA"
    - path: "firmware/imu_firmware/arduino_secrets.h.example"
      provides: "WiFi credentials template"
      contains: "SECRET_SSID"
    - path: "node/serial-bridge.js"
      provides: "UDP listener via dgram, transport handler, transport-aware status"
      contains: "dgram"
  key_links:
    - from: "firmware/imu_firmware/imu_firmware.ino"
      to: "node/serial-bridge.js"
      via: "UDP packets containing same 9-value CSV format"
      pattern: "udp\\.beginPacket|udp\\.write|udp\\.endPacket"
    - from: "node/serial-bridge.js"
      to: "maxAPI.outlet"
      via: "transport handler dispatches to startUDP/startScanning"
      pattern: "addHandler.*transport"
---

<objective>
Add WiFi/UDP as a wireless transport alternative to USB serial. The Arduino firmware gains dual-mode operation (USB serial + WiFi UDP simultaneously), and the Node for Max bridge gains a UDP listener with transport switching logic.

Purpose: Enables wireless sensor data delivery while preserving the existing USB serial path at full performance. This is the transport plumbing that the abstraction (Plan 02) will expose to users.

Output: Updated imu_firmware.ino with WiFiNINA dual-mode, arduino_secrets.h.example template, updated serial-bridge.js with dgram UDP listener and transport handler.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-abstraction-wifi/05-RESEARCH.md
@.planning/phases/05-abstraction-wifi/05-CONTEXT.md
@.planning/phases/01-arduino-firmware/01-01-SUMMARY.md
@.planning/phases/02-serial-bridge/02-01-SUMMARY.md
@firmware/imu_firmware/imu_firmware.ino
@node/serial-bridge.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WiFi dual-mode to Arduino firmware</name>
  <files>firmware/imu_firmware/imu_firmware.ino, firmware/imu_firmware/arduino_secrets.h.example</files>
  <action>
  Update imu_firmware.ino to support WiFi UDP alongside USB serial:

  1. **Create arduino_secrets.h.example** with placeholder WiFi credentials:
     ```
     #define SECRET_SSID "your_wifi_ssid"
     #define SECRET_PASS "your_wifi_password"
     ```

  2. **Add WiFi includes and configuration** at top of imu_firmware.ino (after existing includes):
     ```cpp
     #include <WiFiNINA.h>
     #include <WiFiUdp.h>
     #include "arduino_secrets.h"

     // WiFi configuration
     const int UDP_PORT = 8888;
     IPAddress staticIP(192, 168, 1, 50);
     IPAddress destIP(192, 168, 1, 100);
     const int DEST_PORT = 8889;

     WiFiUDP udp;
     bool wifiConnected = false;
     char csvBuffer[128];
     ```

  3. **Add setupWiFi() function** (called from setup(), AFTER Serial.begin and IMU init, BEFORE warmup):
     ```cpp
     void setupWiFi() {
       WiFi.config(staticIP);
       int status = WiFi.begin(SECRET_SSID, SECRET_PASS);
       if (status == WL_CONNECTED) {
         WiFi.noLowPowerMode();  // Reduces UDP latency from 20ms to 3-5ms
         udp.begin(UDP_PORT);
         wifiConnected = true;
         Serial.println("STARTUP,wifi=connected");
       } else {
         Serial.println("STARTUP,wifi=failed");
       }
     }
     ```
     Call `setupWiFi()` in `setup()` after IMU initialization and before the warmup loop. The blocking WiFi.begin() (up to 10 seconds) happens once at boot, before the main loop starts, so it has zero impact on the 114 Hz data rate.

  4. **Add UDP send in loop()** after the existing Serial.println() of CSV data:
     ```cpp
     if (wifiConnected) {
       int len = snprintf(csvBuffer, sizeof(csvBuffer),
         "%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f",
         ax, ay, az, gx, gy, gz, smoothPitch, smoothRoll, smoothYaw);
       udp.beginPacket(destIP, DEST_PORT);
       udp.write((uint8_t*)csvBuffer, len);
       udp.endPacket();
     }
     ```
     Use `snprintf` to a pre-allocated buffer rather than building the CSV string again. This sends the exact same 9-value CSV format over UDP that USB serial sends.

  5. **Update STARTUP header** to include WiFi status: add `wifi=connected` or `wifi=failed` to the STARTUP line so Node can detect WiFi capability.

  6. **Handle WiFi gracefully if arduino_secrets.h is missing:** Add a preprocessor guard:
     ```cpp
     #if __has_include("arduino_secrets.h")
       #include "arduino_secrets.h"
       #define WIFI_ENABLED
     #else
       #define SECRET_SSID ""
       #define SECRET_PASS ""
     #endif
     ```
     Wrap `setupWiFi()` call and UDP send block in `#ifdef WIFI_ENABLED` guards. This way the firmware compiles and runs USB-only if the user hasn't created arduino_secrets.h.

  IMPORTANT: The existing USB serial output MUST remain completely unchanged. WiFi is purely additive. The variable names for the 9 CSV values must match exactly what the existing code uses. Do NOT modify the main loop timing, warmup, or any existing functionality.

  IMPORTANT: SPI bus contention -- the LSM6DS3 IMU and NINA WiFi module both use SPI. Since the ATmega4809 is single-threaded and calls are sequential (IMU read -> Serial print -> UDP send), there should be no bus contention. But add a comment noting this is a validated assumption.
  </action>
  <verify>
  Run `arduino-cli compile --fqbn arduino:megaavr:uno2018 firmware/imu_firmware/` to verify the firmware compiles cleanly. Check that:
  - Compilation succeeds without errors
  - The file includes WiFiNINA and WiFiUdp headers
  - The WIFI_ENABLED preprocessor guard exists
  - arduino_secrets.h.example exists with placeholder values
  </verify>
  <done>Firmware compiles for arduino:megaavr:uno2018. WiFi UDP send is additive alongside USB serial. WiFi is optional (compiles without arduino_secrets.h). arduino_secrets.h.example provides credential template.</done>
</task>

<task type="auto">
  <name>Task 2: Add UDP transport and transport switching to serial-bridge.js</name>
  <files>node/serial-bridge.js</files>
  <action>
  Update serial-bridge.js to support WiFi UDP alongside USB serial with transport switching:

  1. **Add dgram require** at the top (after existing requires):
     ```javascript
     var dgram = require("dgram");
     ```
     dgram is a Node.js built-in module -- no npm install needed.

  2. **Add transport state variables** near existing state variables:
     ```javascript
     var transport = "usb";       // Current transport mode: "usb", "wifi", "auto"
     var udpSocket = null;        // dgram socket for WiFi
     var udpPort = 8889;          // Default UDP listen port (matches firmware DEST_PORT)
     var wifiIP = "192.168.1.50"; // Arduino IP for status display
     ```

  3. **Implement startUDP(port) function:**
     - Create a UDP4 socket via `dgram.createSocket("udp4")`
     - On "message" event: call `msg.toString().trim()`, then pass through the existing `validateLine()` function. If valid, call `outputData(values)` -- the SAME function USB serial data flows through. This ensures calibration, smoothing, and all processing applies identically.
     - On "listening" event: post to Max console, call `updateStatus("connected-wifi")`
     - On "error" event: post error to Max console, close socket, set udpSocket = null
     - Bind to the specified port on "0.0.0.0" (accept from any sender)

  4. **Implement stopUDP() function:**
     - If udpSocket exists, call udpSocket.close(), set udpSocket = null
     - Do NOT call updateStatus here (the caller manages status)

  5. **Update the updateStatus function** to include transport in status string. Current status values: "disconnected", "scanning", "connected". New values:
     - "disconnected" -- no active transport
     - "scanning" -- looking for USB Arduino
     - "connected-usb" -- receiving data via USB serial
     - "connected-wifi" -- receiving data via WiFi UDP
     - "switching" -- transport change in progress

     Update all existing places that call `updateStatus("connected")` to `updateStatus("connected-usb")`. This is critical -- grep for every `updateStatus` call and update accordingly.

  6. **Add transport handler** via maxAPI.addHandler("transport", ...):
     ```javascript
     maxAPI.addHandler("transport", function() {
       var args = Array.prototype.slice.call(arguments);
       var mode = args[0];
       transport = mode;

       if (mode === "usb") {
         updateStatus("switching");
         stopUDP();
         startScanning();  // existing USB scanning logic
       } else if (mode === "wifi") {
         updateStatus("switching");
         cleanup();  // stop serial port
         if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
         startUDP(udpPort);
       } else if (mode === "auto") {
         updateStatus("switching");
         stopUDP();
         startScanning();
         // After 5s timeout with no USB found, fall back to WiFi
         setTimeout(function() {
           if (state !== "connected-usb") {
             startUDP(udpPort);
           }
         }, 5000);
       }
     });
     ```

  7. **Add udpport handler** to allow configuring the UDP port at runtime:
     ```javascript
     maxAPI.addHandler("udpport", function(port) {
       udpPort = port;
       // If currently on WiFi, restart with new port
       if (udpSocket) {
         stopUDP();
         startUDP(udpPort);
       }
     });
     ```

  8. **Add ip handler** for status display purposes:
     ```javascript
     maxAPI.addHandler("ip", function(addr) {
       wifiIP = addr;
       maxAPI.post("[serial-bridge] Arduino IP set to " + addr);
     });
     ```

  9. **Ensure outputData function exists** as a shared path for both transports. If the current code doesn't have a single outputData function (it may inline the maxAPI.outlet calls in the serial data handler), refactor to extract a shared function:
     ```javascript
     function outputData(values) {
       // values = [ax, ay, az, gx, gy, gz, pitch, roll, yaw]
       maxAPI.outlet("accel", values[0], values[1], values[2]);
       maxAPI.outlet("gyro", values[3], values[4], values[5]);
       maxAPI.outlet("orientation", values[6], values[7], values[8]);
       // ... calibrated outlets if biasOffsets exist ...
       // ... smoothed outlets ...
     }
     ```
     Both the serial line handler and the UDP message handler call this same function.

  IMPORTANT: Do NOT break any existing USB serial functionality. All existing handlers (calibrate_start, calibrate_stop, calibrate_reset, orient_reset, orient_restore, connect, disconnect, listports, reset) must continue to work unchanged. The transport handler is NEW, not a replacement.

  IMPORTANT: The default transport should remain "usb" with startScanning() on script load (existing @autostart behavior). WiFi is opt-in via the transport handler.
  </action>
  <verify>
  Check that:
  - `require("dgram")` is present at the top of serial-bridge.js
  - `startUDP`, `stopUDP` functions exist
  - `maxAPI.addHandler("transport", ...)` exists with usb/wifi/auto modes
  - All existing `updateStatus("connected")` calls are changed to `updateStatus("connected-usb")`
  - The outputData function is shared between serial and UDP paths
  - Existing handlers (calibrate_*, orient_*, connect, disconnect) are unchanged
  - No new npm dependencies required
  </verify>
  <done>serial-bridge.js receives IMU data via both USB serial and WiFi UDP through the same processing pipeline. Transport switching between usb/wifi/auto works via message handler. Status outlet reports transport-aware states. Default behavior unchanged (USB scanning on startup).</done>
</task>

</tasks>

<verification>
1. `arduino-cli compile --fqbn arduino:megaavr:uno2018 firmware/imu_firmware/` compiles without errors
2. serial-bridge.js contains dgram require and UDP functions
3. transport handler accepts "usb", "wifi", "auto" modes
4. Status strings include transport identifier: "connected-usb", "connected-wifi"
5. All existing USB serial functionality is preserved (grep for existing handler names)
6. arduino_secrets.h.example exists with placeholder credentials
</verification>

<success_criteria>
- Firmware compiles with WiFi support (dual-mode) and without (USB-only fallback via preprocessor guard)
- serial-bridge.js can listen for UDP packets and route them through the same validation/calibration/smoothing pipeline as serial data
- Transport switching is functional at the handler level (ready for MAX UI wiring in Plan 02)
- No regressions to existing USB serial pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/05-abstraction-wifi/05-01-SUMMARY.md`
</output>
